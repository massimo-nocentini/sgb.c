\input cwebmac
% This file is part of the Stanford GraphBase (c) Stanford University 1993
% This material goes at the beginning of all Stanford GraphBase CWEB files

\def\topofcontents{
  \leftline{\sc\today\ at \hours}\bigskip\bigskip
  \centerline{\titlefont\title}}

\font\ninett=cmtt9
\def\botofcontents{\vskip 0pt plus 1filll
    \ninerm\baselineskip10pt
    \noindent\copyright\ 1993 Stanford University
    \bigskip\noindent
    This file may be freely copied and distributed, provided that
    no changes whatsoever are made. All users are asked to help keep
    the Stanford GraphBase files consistent and ``uncorrupted,''
    identical everywhere in the world. Changes are permissible only
    if the modified file is given a new name, different from the names of
    existing files in the Stanford GraphBase, and only if the modified file is
    clearly identified as not being part of that GraphBase.
    (The {\ninett CWEB} system has a ``change file'' facility by
    which users can easily make minor alterations without modifying
    the master source files in any way. Everybody is supposed to use
    change files instead of changing the files.)
    The author has tried his best to produce correct and useful programs,
    in order to help promote computer science research,
    but no warranty of any kind should be assumed.
    \smallskip\noindent
    Preliminary work on the Stanford GraphBase project
    was supported in part by National Science
    Foundation grant CCR-86-10181.}

\def\prerequisite#1{\def\startsection{\noindent
    Important: Before reading {\sc\title},
    please read or at least skim the program for {\sc#1}.\bigskip
    \let\startsection=\stsec\stsec}}
\def\prerequisites#1#2{\def\startsection{\noindent
    Important: Before reading {\sc\title}, please read
    or at least skim the programs for {\sc#1} and {\sc#2}.\bigskip
    \let\startsection=\stsec\stsec}}

\def\title{GB\_\,IO}


\N{1}{1}Introduction. This is {\sc GB\_\,IO}, the input/output module used
by all GraphBase routines to access data~files. It doesn't actually do
any output; but somehow `input/output' sounds like a more useful title
than just `input'.

All files of GraphBase data are designed to produce identical results on
almost all existing computers and operating systems. Each line of each file
contains at most 79 characters. Each character is either a blank or a
digit or an uppercase letter or a lowercase letter or a standard punctuation
mark. Blank characters at the end of each line are ``invisible''; that is,
they have no perceivable effect. Hence identical results will be obtained on
record-oriented systems that pad every line with blanks.

The data is carefully sum-checked so that defective input files have little
chance of being accepted.

\fi

\M{2}Changes might be needed when these routines are ported to different
systems. Sections of the program that are most likely to require such changes
are listed under `system dependencies' in the index.

A validation program is provided so that installers can tell if {\sc GB\_\,IO}
is working properly. To make the test, simply run \.{test\_io}.

\Y\B\4\X2:\.{test\_io.c\,}\X${}\E{}$\6
\8\#\&{include} \.{"gb\_io.h"}\C{ all users of {\sc GB\_\,IO} should include
this header file }\6
\8\#\&{define} \1\1\\{exit\_test}(\|m)\C{ we invoke this macro if something
goes wrong }\2\2\6
${}\{{}$\5
\1${}\\{fprintf}(\\{stderr},\39\.{"\%s!\\n(Error\ code\ =\ }\)\.{\%ld)\\n"},\39%
\|m,\39\\{io\_errors}){}$;\5
\&{return} ${}{-}\T{1}{}$;\5
${}\}{}$\2\6
\hbox{\2}\6
\1\1\&{int} \\{main}(\,)\2\2\6
${}\{{}$\1\6
\X28:Test the \PB{\\{gb\_open}} routine; exit if there's trouble\X;\6
\X27:Test the sample data lines; exit if there's trouble\X;\6
\X38:Test the \PB{\\{gb\_close}} routine; exit if there's trouble\X;\6
\\{printf}(\.{"OK,\ the\ gb\_io\ routi}\)\.{nes\ seem\ to\ work!\\n"});\6
\&{return} \T{0};\6
\4${}\}{}$\2\par
\fi

\M{3}The external variable \PB{\\{io\_errors}} mentioned in the previous
section
will be set nonzero if any anomalies are detected. Errors won't occur
in normal use of GraphBase programs, so no attempt has been made to
provide a user-friendly way to decode the nonzero values that
\PB{\\{io\_errors}} might assume.  Information is simply gathered in binary
form; system wizards who might need to do a bit of troubleshooting
should be able to decode \PB{\\{io\_errors}} without great pain.

\Y\B\4\D$\\{cant\_open\_file}$ \5
\T{\^1}\C{ bit set in \PB{\\{io\_errors}} if \PB{\\{fopen}} fails }\par
\B\4\D$\\{cant\_close\_file}$ \5
\T{\^2}\C{ bit set if \PB{\\{fclose}} fails }\par
\B\4\D$\\{bad\_first\_line}$ \5
\T{\^4}\C{ bit set if the data file's first line isn't legit }\par
\B\4\D$\\{bad\_second\_line}$ \5
\T{\^8}\C{ bit set if the second line doesn't pass muster }\par
\B\4\D$\\{bad\_third\_line}$ \5
\T{\^10}\C{ bit set if the third line is awry }\par
\B\4\D$\\{bad\_fourth\_line}$ \5
\T{\^20}\C{ guess when this bit is set }\par
\B\4\D$\\{file\_ended\_prematurely}$ \5
\T{\^40}\C{ bit set if \PB{\\{fgets}} fails }\par
\B\4\D$\\{missing\_newline}$ \5
\T{\^80}\C{ bit set if line is too long or \PB{\.{'\\n'}} is missing }\par
\B\4\D$\\{wrong\_number\_of\_lines}$ \5
\T{\^100}\C{ bit set if the line count is wrong }\par
\B\4\D$\\{wrong\_checksum}$ \5
\T{\^200}\C{ bit set if the checksum is wrong }\par
\B\4\D$\\{no\_file\_open}$ \5
\T{\^400}\C{ bit set if user tries to close an unopened file }\par
\B\4\D$\\{bad\_last\_line}$ \5
\T{\^800}\C{ bit set if final line has incorrect form }\par
\fi

\M{4}The \CEE/ code for {\sc GB\_\,IO} doesn't have a main routine; it's just a
bunch of subroutines to be incorporated into programs at a higher level
via the system loading routine. Here is the general outline of \.{gb\_io.c}:

\Y\B\X7:Header files to include\X\6
\ATH\6
\X5:External declarations\X\6
\X8:Private declarations\X\6
\X9:Internal functions\X\6
\X12:External functions\X\par
\fi

\M{5}Every external variable is declared twice in this \.{CWEB} file:
once for {\sc GB\_\,IO} itself (the ``real'' declaration for storage
allocation purposes) and once in \.{gb\_io.h} (for cross-references
by {\sc GB\_\,IO} users).

\Y\B\4\X5:External declarations\X${}\E{}$\6
\&{long} \\{io\_errors};\C{ record of anomalies noted by {\sc GB\_\,IO}
routines }\par
\U4.\fi

\M{6}\B\X6:\.{gb\_io.h\,}\X${}\E{}$\6
\X7:Header files to include\X\7
\&{extern} \&{long} \\{io\_errors};\C{ record of anomalies noted by {\sc GB\_%
\,IO} routines }\par
\As13, 16, 19, 21, 23, 25, 29\ETs41.\fi

\M{7}We will stick to standard \CEE/-type input conventions. We'll also have
occasion to use some of the standard string operations.

\Y\B\4\X7:Header files to include\X${}\E{}$\6
\8\#\&{include} \.{<stdio.h>}\6
\8\#\&{ifdef} \.{SYSV}\6
\8\#\&{include} \.{<string.h>}\6
\8\#\&{else}\6
\8\#\&{include} \.{<strings.h>}\6
\8\#\&{endif}\par
\Us4\ET6.\fi

\N{1}{8}Inputting a line. The {\sc GB\_\,IO} routines get their input from
an array called \PB{\\{buffer}}. This array is internal to {\sc
GB\_\,IO}---its contents are hidden from user programs. We make it 81
characters long, since the data is supposed to have at most 79
characters per line, followed by newline and null.

\Y\B\4\X8:Private declarations\X${}\E{}$\6
\&{static} \&{char} \\{buffer}[\T{81}];\C{ the current line of input }\6
\&{static} \&{char} ${}{*}\\{cur\_pos}\K\\{buffer}{}$;\C{ the current character
of interest }\6
\&{static} \&{FILE} ${}{*}\\{cur\_file}{}$;\C{ current file, or \PB{$\NULL$} if
none is open }\par
\As10, 11\ETs33.
\U4.\fi

\M{9}Here's a basic subroutine to fill the \PB{\\{buffer}}. The main feature of
interest
is the removal of trailing blanks. We assume that \PB{\\{cur\_file}} is open.

Notice that a line of 79 characters (followed by \PB{\.{'\\n'}}) will just fit
into
the buffer, and will cause no errors. A line of 80 characters will
be split into two lines and the \PB{\\{missing\_newline}}
message will occur, because of the way \PB{\\{fgets}} is defined. A \PB{%
\\{missing\_newline}}
error will also occur if the file ends in the middle of a line, or if
a null character (\PB{\.{'\\0'}}) occurs within a line.

\Y\B\4\X9:Internal functions\X${}\E{}$\6
\1\1\&{static} \&{void} \\{fill\_buf}(\,)\2\2\6
${}\{{}$\5
\1\&{register} \&{char} ${}{*}\|p;{}$\7
\&{if} ${}(\R\\{fgets}(\\{buffer},\39{}$\&{sizeof} (\\{buffer})${},\39\\{cur%
\_file})){}$\5
${}\{{}$\1\6
${}\\{io\_errors}\MRL{{\OR}{\K}}\\{file\_ended\_prematurely};{}$\6
${}\\{buffer}[\T{0}]\K\\{more\_data}\K\T{0};{}$\6
\4${}\}{}$\2\6
\&{for} ${}(\|p\K\\{buffer};{}$ ${}{*}\|p;{}$ ${}\|p\PP){}$\1\5
;\C{ advance to first null character }\2\6
\&{if} ${}(\|p\MM\E\\{buffer}\V{*}\|p\I\.{'\\n'}){}$\5
${}\{{}$\1\6
${}\\{io\_errors}\MRL{{\OR}{\K}}\\{missing\_newline};{}$\6
${}\|p\PP;{}$\6
\4${}\}{}$\2\6
\&{while} ${}(\MM\|p\G\\{buffer}\W{*}\|p\E\.{'\ '}){}$\1\5
;\C{ move back over trailing blanks }\2\6
${}{*}\PP\|p\K\.{'\\n'};{}$\6
${}{*}\PP\|p\K\T{0}{}$;\C{ newline and null are always present at end of line }%
\6
${}\\{cur\_pos}\K\\{buffer}{}$;\C{ get ready to read \PB{\\{buffer}[\T{0}]} }\6
\4${}\}{}$\2\par
\A15.
\U4.\fi

\N{1}{10}Checksums. Each data file has a ``magic number,'' which is defined to
be
$$\biggl(\sum_l 2^l c_l\biggr) \bmod p\,.$$
Here $p$ is a large prime number, and $c_l$ denotes the internal code
corresponding to the $l$th-from-last
data character read (including newlines but not nulls).

The ``internal codes'' $c_l$ are computed in a system-independent way:
Each character \PB{\|c} in the actual encoding scheme being used has a
corresponding \PB{\\{icode}}, which is the same on all systems. For example,
the \PB{\\{icode}} of \PB{\.{'0'}} is zero, regardless of whether \PB{\.{'0'}}
is actually
represented in ASCII or EBCDIC or some other scheme. (We assume that
every modern computer system is capable of printing at least 95
different characters, including a blank space.)

We will accept a data file as error-free if it has the correct number of
lines and ends with the proper magic number.

\Y\B\4\X8:Private declarations\X${}\mathrel+\E{}$\6
\&{static} \&{char} \\{icode}[\T{256}];\C{ mapping of characters to internal
codes }\6
\&{static} \&{long} \\{checksum\_prime}${}\K(\T{1\$L}\LL\T{30})-\T{83}{}$;\C{
large prime such that $2p+\PB{\\{unexpected\_char}}$ won't overflow }\6
\&{static} \&{long} \\{magic};\C{ current checksum value }\6
\&{static} \&{long} \\{line\_no};\C{ current line number in file }\6
\&{static} \&{long} \\{final\_magic};\C{ desired final magic number }\6
\&{static} \&{long} \\{tot\_lines};\C{ total number of data lines }\6
\&{static} \&{char} \\{more\_data};\C{ is there data still waiting to be read?
}\par
\fi

\M{11}The \PB{\\{icode}} mapping is defined by a single string, \PB{\\{imap}},
such that
character \PB{\\{imap}[\|k]} has \PB{\\{icode}} value~\PB{\|k}. There are 96
characters
in \PB{\\{imap}}, namely the 94 standard visible ASCII codes plus space
and newline. If EBCDIC code is used instead of ASCII, the
cents sign \rlap{\.{\kern.05em/}}\.c should take the place of single-left-quote
\.{\char`\`}, and \.{\char5}~should take the place of\/~\.{\char`\~}.

All characters that don't appear in \PB{\\{imap}} are given the same \PB{%
\\{icode}}
value, called \PB{\\{unexpected\_char}}. Such characters should be avoided in
GraphBase files whenever possible. (If they do appear, they can still
get into a user's data, but we don't distinguish them from each other
for checksumming purposes.)

The \PB{\\{icode}} table actually plays a dual role, because we've rigged it so
that
codes 0--15 come from the characters \PB{\.{"0123456789ABCDEF"}}. This
facilitates
conversion of decimal and hexadecimal data. We can also use it for
radices higher than 16.

\Y\B\4\D$\\{unexpected\_char}$ \5
\T{127}\C{ default \PB{\\{icode}} value }\par
\Y\B\4\X8:Private declarations\X${}\mathrel+\E{}$\6
\&{static} \&{char} ${}{*}\\{imap}\K\.{"0123456789ABCDEFGHI}\)%
\.{JKLMNOPQRSTUVWXYZabc}\)\.{defghijklmnopqrstuvw}\)\.{xyz\_\^\~\&@,;.:?!\%\#%
\$+-*}\)\.{/|\\\\<=>()[]\{\}`'\\"\ \\n}\)\.{"}{}$;\par
\fi

\M{12}Users of {\sc GB\_\,IO} can look at the \PB{\\{imap}}, but they can't
change it.

\Y\B\4\X12:External functions\X${}\E{}$\6
\1\1\&{char} \\{imap\_chr}(\|d)\6
\&{long} \|d;\2\2\6
${}\{{}$\1\6
\&{return} \|d${}<\T{0}\V\|d>\\{strlen}(\\{imap})\?\.{'\\0'}:\\{imap}[\|d];{}$\6
\4${}\}{}$\2\7
\1\1\&{long} \\{imap\_ord}(\|c)\6
\&{char} \|c;\2\2\6
${}\{{}$\1\6
\X14:Make sure that \PB{\\{icode}} has been initialized\X;\6
\&{return} ${}(\|c<\T{0}\V\|c>\T{255})\?\\{unexpected\_char}:\\{icode}[\|c];{}$%
\6
\4${}\}{}$\2\par
\As17, 18, 20, 22, 24, 26, 30, 32, 39\ETs42.
\U4.\fi

\M{13}\B\X6:\.{gb\_io.h\,}\X${}\mathrel+\E{}$\6
\8\#\&{define} \\{unexpected\_char}\5\hbox{\quad}\T{127}\6
\&{extern} \&{char} \\{imap\_chr}(\,);\C{ the character that maps to a given
character }\6
\&{extern} \&{long} \\{imap\_ord}(\,);\C{ the ordinal number of a given
character }\par
\fi

\M{14}\B\X14:Make sure that \PB{\\{icode}} has been initialized\X${}\E{}$\6
\&{if} ${}(\R\\{icode}[\.{'1'}]){}$\1\5
\\{icode\_setup}(\,);\2\par
\Us12\ET30.\fi

\M{15}\B\X9:Internal functions\X${}\mathrel+\E{}$\6
\1\1\&{static} \&{void} \\{icode\_setup}(\,)\2\2\6
${}\{{}$\5
\1\&{register} \&{long} \|k;\6
\&{register} \&{char} ${}{*}\|p;{}$\7
\&{for} ${}(\|k\K\T{0};{}$ ${}\|k<\T{256};{}$ ${}\|k\PP){}$\1\5
${}\\{icode}[\|k]\K\\{unexpected\_char};{}$\2\6
\&{for} ${}(\|p\K\\{imap},\39\|k\K\T{0};{}$ ${}{*}\|p;{}$ ${}\|p\PP,\39\|k%
\PP){}$\1\5
${}\\{icode}[{*}\|p]\K\|k;{}$\2\6
\4${}\}{}$\2\par
\fi

\M{16}Now we're ready to specify some external subroutines that do
input.  Calling \PB{\\{gb\_newline}(\,)} will read the next line of
data into \PB{\\{buffer}} and update the magic number accordingly.

\Y\B\4\X6:\.{gb\_io.h\,}\X${}\mathrel+\E{}$\6
\&{extern} \&{void} \\{gb\_newline}(\,);\C{ advance to next line of the data
file }\6
\&{extern} \&{long} \\{new\_checksum}(\,);\C{ compute change in magic number }%
\par
\fi

\M{17}Users can compute checksums as \PB{\\{gb\_newline}} does, but they can't
change the (private) value of \PB{\\{magic}}.

\Y\B\4\X12:External functions\X${}\mathrel+\E{}$\6
\1\1\&{long} ${}\\{new\_checksum}(\|s,\39\\{old\_checksum}){}$\6
\&{char} ${}{*}\|s{}$;\C{ a string }\6
\&{long} \\{old\_checksum};\2\2\6
${}\{{}$\5
\1\&{register} \&{long} \|a${}\K\\{old\_checksum};{}$\6
\&{register} \&{char} ${}{*}\|p;{}$\7
\&{for} ${}(\|p\K\|s;{}$ ${}{*}\|p;{}$ ${}\|p\PP){}$\1\5
${}\|a\K(\|a+\|a+\\{imap\_ord}({*}\|p))\MOD\\{checksum\_prime};{}$\2\6
\&{return} \|a;\6
\4${}\}{}$\2\par
\fi

\M{18}The magic checksum is not affected by lines that begin with \.*.

\Y\B\4\X12:External functions\X${}\mathrel+\E{}$\6
\1\1\&{void} \\{gb\_newline}(\,)\2\2\6
${}\{{}$\1\6
\&{if} ${}(\PP\\{line\_no}>\\{tot\_lines}){}$\1\5
${}\\{more\_data}\K\T{0};{}$\2\6
\&{if} (\\{more\_data})\5
${}\{{}$\1\6
\\{fill\_buf}(\,);\6
\&{if} ${}(\\{buffer}[\T{0}]\I\.{'*'}){}$\1\5
${}\\{magic}\K\\{new\_checksum}(\\{buffer},\39\\{magic});{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\fi

\M{19}Another simple routine allows a user to read (but not write) the
variable \PB{\\{more\_data}}.

\Y\B\4\X6:\.{gb\_io.h\,}\X${}\mathrel+\E{}$\6
\&{extern} \&{long} \\{gb\_eof}(\,);\C{ has the data all been read? }\par
\fi

\M{20}\B\X12:External functions\X${}\mathrel+\E{}$\6
\1\1\&{long} \\{gb\_eof}(\,)\2\2\6
${}\{{}$\1\6
\&{return} ${}\R\\{more\_data};{}$\6
\4${}\}{}$\2\par
\fi

\N{1}{21}Parsing a line. The user can input characters from the buffer in
several
ways. First, there's a basic \PB{\\{gb\_char}(\,)} routine, which returns
a single character. The character is \PB{\.{'\\n'}} if the last character on
the
line has already been read (and it continues to be \PB{\.{'\\n'}} until the
user calls
\PB{\\{gb\_newline}}).

The current position in the line, \PB{\\{cur\_pos}}, always advances when \PB{%
\\{gb\_char}}
is called, unless \PB{\\{cur\_pos}} was already at the end of the line.
There's also a \PB{\\{gb\_backup}(\,)} routine, which moves \PB{\\{cur\_pos}}
one place
to the left unless it was already at the beginning.

\Y\B\4\X6:\.{gb\_io.h\,}\X${}\mathrel+\E{}$\6
\&{extern} \&{char} \\{gb\_char}(\,);\C{ get next character of current line, or
\PB{\.{'\\n'}} }\6
\&{extern} \&{void} \\{gb\_backup}(\,);\C{ move back ready to scan a character
again }\par
\fi

\M{22}\B\X12:External functions\X${}\mathrel+\E{}$\6
\1\1\&{char} \\{gb\_char}(\,)\2\2\6
${}\{{}$\1\6
\&{if} ${}({*}\\{cur\_pos}){}$\1\5
\&{return} ${}({*}\\{cur\_pos}\PP);{}$\2\6
\&{return} \.{'\\n'};\6
\4${}\}{}$\2\7
\1\1\&{void} \\{gb\_backup}(\,)\2\2\6
${}\{{}$\1\6
\&{if} ${}(\\{cur\_pos}>\\{buffer}){}$\1\5
${}\\{cur\_pos}\MM;{}$\2\6
\4${}\}{}$\2\par
\fi

\M{23}There are two ways to read numerical data. The first, \PB{\\{gb\_digit}(%
\|d)},
expects to read a single character in radix~\PB{\|d}, using \PB{\\{icode}}
values
to specify digits greater than~9. (Thus, for example, \PB{\.{'A'}} represents
the hexadecimal digit for decimal~10.)
If the next character is a valid \PB{\|d}-git,
\PB{\\{cur\_pos}} moves to the next character and the numerical value is
returned.
Otherwise \PB{\\{cur\_pos}} stays in the same place and $-1$ is returned.

The second routine, \PB{\\{gb\_number}(\|d)}, reads characters and forms an
unsigned radix-\PB{\|d} number until the first non-digit is encountered.
The resulting number is returned; it is zero if no digits were found.
No errors are possible with this routine, because it uses
\PB{\&{unsigned} \&{long}} arithmetic.

\Y\B\4\X6:\.{gb\_io.h\,}\X${}\mathrel+\E{}$\6
\&{extern} \&{long} \\{gb\_digit}(\,);\C{ \PB{\\{gb\_digit}(\|d)} reads a digit
between 0 and \PB{$\|d-\T{1}$} }\6
\&{extern} \&{unsigned} \&{long} \\{gb\_number}(\,);\C{ \PB{\\{gb\_number}(%
\|d)} reads a radix-\PB{\|d} number }\par
\fi

\M{24}The value of \PB{\|d} should be at most 127, if users want their programs
to be
portable, because \CEE/ does not treat larger \PB{\&{char}} values in a
well-defined manner. In most applications, \PB{\|d} is of course either 10 or
16.

\Y\B\4\X12:External functions\X${}\mathrel+\E{}$\6
\1\1\&{long} \\{gb\_digit}(\|d)\6
\&{char} \|d;\2\2\6
${}\{{}$\1\6
${}\\{icode}[\T{0}]\K\|d{}$;\C{ make sure \PB{\.{'\\0'}} is a nondigit }\6
\&{if} ${}(\\{imap\_ord}({*}\\{cur\_pos})<\|d){}$\1\5
\&{return} \\{icode}${}[{*}\\{cur\_pos}\PP];{}$\2\6
\&{return} ${}{-}\T{1};{}$\6
\4${}\}{}$\2\7
\1\1\&{unsigned} \&{long} \\{gb\_number}(\|d)\6
\&{char} \|d;\2\2\6
${}\{{}$\5
\1\&{register} \&{unsigned} \&{long} \|a${}\K\T{0};{}$\7
${}\\{icode}[\T{0}]\K\|d{}$;\C{ make sure \PB{\.{'\\0'}} is a nondigit }\6
\&{while} ${}(\\{imap\_ord}({*}\\{cur\_pos})<\|d){}$\1\5
${}\|a\K\|a*\|d+\\{icode}[{*}\\{cur\_pos}\PP];{}$\2\6
\&{return} \|a;\6
\4${}\}{}$\2\par
\fi

\M{25}The final subroutine for fetching data is \PB{$\\{gb\_string}(\|p,\|c)$},
which
stores a null-terminated string into locations starting at~\PB{\|p}.
The string starts at \PB{\\{cur\_pos}} and ends just before the first
appearance
of character \PB{\|c}. If \PB{$\|c\E\.{'\\n'}$}, the string will stop at the
end of the line.
If \PB{\|c} doesn't appear in the buffer at or after \PB{\\{cur\_pos}}, the
last character
of the string will be the \PB{\.{'\\n'}} that is always inserted at the end
of a line, unless the entire line has already been read. (If the entire
line has previously been read, the empty string is always returned.)
After the string has been copied, \PB{\\{cur\_pos}} advances past it.

In order to use this routine safely, the user should first check that
there is room to store up to 81 characters beginning at location~\PB{\|p}.
A suitable place to put the result, called \PB{\\{str\_buf}}, is provided
for the user's convenience.

The location following the stored string is returned. Thus, if the
stored string has length~\PB{\|l} (not counting the null character that is
stored at the end), the value returned will be \PB{$\|p+\|l+\T{1}$}.

\Y\B\4\X6:\.{gb\_io.h\,}\X${}\mathrel+\E{}$\6
\8\#\&{define} \.{STR\_BUF\_LENGTH}\5\T{160}\6
\&{extern} \&{char} \\{str\_buf}[\,];\C{ safe place to receive output of \PB{%
\\{gb\_string}} }\6
\&{extern} \&{char} ${}{*}\\{gb\_string}(\,){}$;\C{ \PB{$\\{gb\_string}(\|p,%
\|c)$} reads a string delimited by \PB{\|c}   into bytes starting at \PB{\|p} }%
\par
\fi

\M{26}\B\D$\.{STR\_BUF\_LENGTH}$ \5
\T{160}\par
\Y\B\4\X12:External functions\X${}\mathrel+\E{}$\6
\&{char} \\{str\_buf}[\.{STR\_BUF\_LENGTH}];\C{ users can put strings here if
they wish }\7
\1\1\&{char} ${}{*}\\{gb\_string}(\|p,\39\|c){}$\6
\&{char} ${}{*}\|p{}$;\C{ where to put the result }\6
\&{char} \|c;\C{ character following the string }\2\2\6
${}\{{}$\1\6
\&{while} ${}({*}\\{cur\_pos}\W{*}\\{cur\_pos}\I\|c){}$\1\5
${}{*}\|p\PP\K{*}\\{cur\_pos}\PP;{}$\2\6
${}{*}\|p\PP\K\T{0};{}$\6
\&{return} \|p;\6
\4${}\}{}$\2\par
\fi

\M{27}Here's how we test those routines in \.{test\_io}: The first line of test
data consists of 79 characters, beginning with 64 zeroes and ending with
`\.{123456789ABCDEF}'. The second line is completely blank. The third
and final line says `\.{Oops:(intentional mistake)}'.

\Y\B\4\X27:Test the sample data lines; exit if there's trouble\X${}\E{}$\6
\&{if} ${}(\\{gb\_number}(\T{10})\I\T{123456789}){}$\1\5
${}\\{io\_errors}\MRL{{\OR}{\K}}\T{1\$L}\LL\T{20}{}$;\C{ decimal number not
working }\2\6
\&{if} ${}(\\{gb\_digit}(\T{16})\I\T{10}){}$\1\5
${}\\{io\_errors}\MRL{{\OR}{\K}}\T{1\$L}\LL\T{21}{}$;\C{ we missed the \.A
following the decimal number }\2\6
\\{gb\_backup}(\,);\5
\\{gb\_backup}(\,);\C{ get set to read `\.{9A}' again }\6
\&{if} ${}(\\{gb\_number}(\T{16})\I\T{\^9ABCDEF}){}$\1\5
${}\\{io\_errors}\MRL{{\OR}{\K}}\T{1\$L}\LL\T{22}{}$;\C{ hexadecimal number not
working }\2\6
\\{gb\_newline}(\,);\C{ now we should be scanning a blank line }\6
\&{if} ${}(\\{gb\_char}(\,)\I\.{'\\n'}){}$\1\5
${}\\{io\_errors}\MRL{{\OR}{\K}}\T{1\$L}\LL\T{23}{}$;\C{ newline not inserted
at end }\2\6
\&{if} ${}(\\{gb\_char}(\,)\I\.{'\\n'}){}$\1\5
${}\\{io\_errors}\MRL{{\OR}{\K}}\T{1\$L}\LL\T{24}{}$;\C{ newline not implied
after end }\2\6
\&{if} ${}(\\{gb\_number}(\T{60})\I\T{0}){}$\1\5
${}\\{io\_errors}\MRL{{\OR}{\K}}\T{1\$L}\LL\T{25}{}$;\C{ number should stop at
null character }\2\6
${}\{{}$\5
\1\&{char} \\{temp}[\T{100}];\7
\&{if} ${}(\\{gb\_string}(\\{temp},\39\.{'\\n'})\I\\{temp}+\T{1}){}$\1\5
${}\\{io\_errors}\MRL{{\OR}{\K}}\T{1\$L}\LL\T{26}{}$;\C{ string should be null
after end of line }\2\6
\\{gb\_newline}(\,);\6
\&{if} ${}(\\{gb\_string}(\\{temp},\39\.{':'})\I\\{temp}+\T{5}\V\\{strcmp}(%
\\{temp},\39\.{"Oops"})){}$\1\5
${}\\{io\_errors}\MRL{{\OR}{\K}}\T{1\$L}\LL\T{27}{}$;\C{ string not read
properly }\2\6
\4${}\}{}$\2\6
\&{if} (\\{io\_errors})\1\5
\\{exit\_test}(\.{"Sorry,\ it\ failed.\ L}\)\.{ook\ at\ the\ error\ cod}\)\.{e\
for\ clues"});\2\6
\&{if} ${}(\\{gb\_digit}(\T{10})\I{-}\T{1}){}$\1\5
\\{exit\_test}(\.{"Digit\ error\ not\ det}\)\.{ected"});\2\6
\&{if} ${}(\\{gb\_char}(\,)\I\.{':'}){}$\1\5
${}\\{io\_errors}\MRL{{\OR}{\K}}\T{1\$L}\LL\T{28}{}$;\C{ lost synch after \PB{%
\\{gb\_string}} and \PB{\\{gb\_digit}} }\2\6
\&{if} (\\{gb\_eof}(\,))\1\5
${}\\{io\_errors}\MRL{{\OR}{\K}}\T{1\$L}\LL\T{29}{}$;\C{ premature end-of-file
indication }\2\6
\\{gb\_newline}(\,);\6
\&{if} ${}(\R\\{gb\_eof}(\,)){}$\1\5
${}\\{io\_errors}\MRL{{\OR}{\K}}\T{1\$L}\LL\T{30}{}$;\C{ postmature end-of-file
indication }\2\par
\U2.\fi

\N{1}{28}Opening a file. The call \PB{\\{gb\_raw\_open}(\.{"foo"})} will open
file \PB{\.{"foo"}} and
initialize the checksumming process. If the file cannot be opened,
\PB{\\{io\_errors}} will be set to \PB{\\{cant\_open\_file}}, otherwise
\PB{\\{io\_errors}} will be initialized to zero.

The call \PB{\\{gb\_open}(\.{"foo"})} is a stronger version of \PB{\\{gb\_raw%
\_open}}, which
is used for standard GraphBase data files like \PB{\.{"words.dat"}} to make
doubly sure that they have not been corrupted. It returns the current value
of \PB{\\{io\_errors}}, which will be nonzero if any problems were detected
at the beginning of the file.

\Y\B\4\X28:Test the \PB{\\{gb\_open}} routine; exit if there's trouble\X${}%
\E{}$\6
\&{if} ${}(\\{gb\_open}(\.{"test.dat"})\I\T{0}){}$\1\5
\\{exit\_test}(\.{"Can't\ open\ test.dat}\)\.{"});\2\par
\U2.\fi

\M{29}\B\D$\\{gb\_raw\_open}$ \5
\\{gb\_r\_open}\C{ abbreviation for Procrustean external linkage }\par
\Y\B\4\X6:\.{gb\_io.h\,}\X${}\mathrel+\E{}$\6
\8\#\&{define} \\{gb\_raw\_open}\5\\{gb\_r\_open}\6
\&{extern} \&{void} \\{gb\_raw\_open}(\,);\C{ open a file for GraphBase input }%
\6
\&{extern} \&{long} \\{gb\_open}(\,);\C{ open a GraphBase data file; return 0
if OK }\par
\fi

\M{30}\B\X12:External functions\X${}\mathrel+\E{}$\6
\1\1\&{void} \\{gb\_raw\_open}(\|f)\6
\&{char} ${}{*}\|f;\2\2{}$\6
${}\{{}$\1\6
\X14:Make sure that \PB{\\{icode}} has been initialized\X;\6
\X31:Try to open \PB{\|f}\X;\6
\&{if} (\\{cur\_file})\5
${}\{{}$\1\6
${}\\{io\_errors}\K\T{0};{}$\6
${}\\{more\_data}\K\T{1};{}$\6
${}\\{line\_no}\K\\{magic}\K\T{0};{}$\6
${}\\{tot\_lines}\K\T{\^7fffffff}{}$;\C{ allow ``infinitely many'' lines }\6
\\{fill\_buf}(\,);\6
\4${}\}{}$\5
\2\&{else}\1\5
${}\\{io\_errors}\K\\{cant\_open\_file};{}$\2\6
\4${}\}{}$\2\par
\fi

\M{31}Here's a possibly system-dependent part of the code: We try first to
open the data file by using the file name itself as the path name;
failing that, we try to prefix the file name with the name of the
standard directory for GraphBase data, if the program has been compiled
with \PB{\.{DATA\_DIRECTORY}} defined.

\Y\B\4\X31:Try to open \PB{\|f}\X${}\E{}$\6
$\\{cur\_file}\K\\{fopen}(\|f,\39\.{"r"});{}$\6
\8\#\&{ifdef} \.{DATA\_DIRECTORY}\6
\&{if} ${}(\R\\{cur\_file}\W(\\{strlen}(\.{DATA\_DIRECTORY})+\\{strlen}(\|f)<%
\.{STR\_BUF\_LENGTH})){}$\5
${}\{{}$\1\6
${}\\{sprintf}(\\{str\_buf},\39\.{"\%s\%s"},\39\.{DATA\_DIRECTORY},\39\|f);{}$\6
${}\\{cur\_file}\K\\{fopen}(\\{str\_buf},\39\.{"r"});{}$\6
\4${}\}{}$\2\6
\8\#\&{endif}\par
\U30.\fi

\M{32}\B\X12:External functions\X${}\mathrel+\E{}$\6
\1\1\&{long} \\{gb\_open}(\|f)\6
\&{char} ${}{*}\|f;\2\2{}$\6
${}\{{}$\1\6
${}\\{strncpy}(\\{file\_name},\39\|f,\39{}$\&{sizeof} (\\{file\_name})${}-%
\T{1}){}$;\C{ save the name for use by \PB{\\{gb\_close}} }\6
\\{gb\_raw\_open}(\|f);\6
\&{if} (\\{cur\_file})\5
${}\{{}$\1\6
\X34:Check the first line; return if unsuccessful\X;\6
\X35:Check the second line; return if unsuccessful\X;\6
\X36:Check the third line; return if unsuccessful\X;\6
\X37:Check the fourth line; return if unsuccessful\X;\6
\\{gb\_newline}(\,);\C{ the first line of real data is now in the buffer }\6
\4${}\}{}$\2\6
\&{return} \\{io\_errors};\6
\4${}\}{}$\2\par
\fi

\M{33}\B\X8:Private declarations\X${}\mathrel+\E{}$\6
\&{static} \&{char} \\{file\_name}[\T{20}];\C{ name of the data file, without a
prefix }\par
\fi

\M{34}The first four lines of a typical data file should look something like
this:
$$\halign{\hskip5em\.{#}\hfill\cr
* File "words.dat" from the Stanford GraphBase (C) 1993 Stanford University\cr
* A database of English five-letter words\cr
* This file may be freely copied but please do not change it in any way!\cr
* (Checksum parameters 5757,526296596)\cr}$$
We actually verify only that the first four lines of a data file named \PB{%
\.{"foo"}}
begin respectively with the characters
$$\halign{\hskip5em\.{#}\hfill\cr
* File "foo"\cr
*\cr
*\cr
* (Checksum parameters $l$,$m$)\cr}$$
where $l$ and $m$ are decimal numbers. The values of $l$ and~$m$
are stored away as \PB{\\{tot\_lines}} and \PB{\\{final\_magic}}, to be matched
at the
end of the file.

\Y\B\4\X34:Check the first line; return if unsuccessful\X${}\E{}$\6
$\\{sprintf}(\\{str\_buf},\39\.{"*\ File\ \\"\%s\\""},\39\|f);{}$\6
\&{if} ${}(\\{strncmp}(\\{buffer},\39\\{str\_buf},\39\\{strlen}(\\{str%
\_buf}))){}$\1\5
\&{return} ${}(\\{io\_errors}\MRL{{\OR}{\K}}\\{bad\_first\_line}){}$;\2\par
\U32.\fi

\M{35}\B\X35:Check the second line; return if unsuccessful\X${}\E{}$\6
\\{fill\_buf}(\,);\6
\&{if} ${}({*}\\{buffer}\I\.{'*'}){}$\1\5
\&{return} ${}(\\{io\_errors}\MRL{{\OR}{\K}}\\{bad\_second\_line}){}$;\2\par
\U32.\fi

\M{36}\B\X36:Check the third line; return if unsuccessful\X${}\E{}$\6
\\{fill\_buf}(\,);\6
\&{if} ${}({*}\\{buffer}\I\.{'*'}){}$\1\5
\&{return} ${}(\\{io\_errors}\MRL{{\OR}{\K}}\\{bad\_third\_line}){}$;\2\par
\U32.\fi

\M{37}\B\X37:Check the fourth line; return if unsuccessful\X${}\E{}$\6
\\{fill\_buf}(\,);\6
\&{if} ${}(\\{strncmp}(\\{buffer},\39\.{"*\ (Checksum\ paramet}\)\.{ers\ "},\39%
\T{23})){}$\1\5
\&{return} ${}(\\{io\_errors}\MRL{{\OR}{\K}}\\{bad\_fourth\_line});{}$\2\6
${}\\{cur\_pos}\MRL{+{\K}}\T{23};{}$\6
${}\\{tot\_lines}\K\\{gb\_number}(\T{10});{}$\6
\&{if} ${}(\\{gb\_char}(\,)\I\.{','}){}$\1\5
\&{return} ${}(\\{io\_errors}\MRL{{\OR}{\K}}\\{bad\_fourth\_line});{}$\2\6
${}\\{final\_magic}\K\\{gb\_number}(\T{10});{}$\6
\&{if} ${}(\\{gb\_char}(\,)\I\.{')'}){}$\1\5
\&{return} ${}(\\{io\_errors}\MRL{{\OR}{\K}}\\{bad\_fourth\_line}){}$;\2\par
\U32.\fi

\N{1}{38}Closing a file. After all data has been input, or should have been
input,
we check that the file was open and that it had the correct number of
lines, the correct magic number, and a correct final line.  The
subroutine \PB{\\{gb\_close}}, like \PB{\\{gb\_open}}, returns the value of
\PB{\\{io\_errors}}, which will be nonzero if at least one problem was noticed.

\Y\B\4\X38:Test the \PB{\\{gb\_close}} routine; exit if there's trouble\X${}%
\E{}$\6
\&{if} ${}(\\{gb\_close}(\,)\I\T{0}){}$\1\5
\\{exit\_test}(\.{"Bad\ checksum,\ or\ di}\)\.{fficulty\ closing\ the}\)\.{\
file"});\2\par
\U2.\fi

\M{39}\B\X12:External functions\X${}\mathrel+\E{}$\6
\1\1\&{long} \\{gb\_close}(\,)\2\2\6
${}\{{}$\1\6
\&{if} ${}(\R\\{cur\_file}){}$\1\5
\&{return} ${}(\\{io\_errors}\MRL{{\OR}{\K}}\\{no\_file\_open});{}$\2\6
\\{fill\_buf}(\,);\6
${}\\{sprintf}(\\{str\_buf},\39\.{"*\ End\ of\ file\ \\"\%s\\}\)\.{""},\39%
\\{file\_name});{}$\6
\&{if} ${}(\\{strncmp}(\\{buffer},\39\\{str\_buf},\39\\{strlen}(\\{str%
\_buf}))){}$\1\5
${}\\{io\_errors}\MRL{{\OR}{\K}}\\{bad\_last\_line};{}$\2\6
${}\\{more\_data}\K\\{buffer}[\T{0}]\K\T{0}{}$;\C{ now the {\sc GB\_\,IO}
routines are effectively shut down }\C{ we have \PB{$\\{cur\_pos}\K\\{buffer}$}
}\6
\&{if} ${}(\\{fclose}(\\{cur\_file})\I\T{0}){}$\1\5
\&{return} ${}(\\{io\_errors}\MRL{{\OR}{\K}}\\{cant\_close\_file});{}$\2\6
${}\\{cur\_file}\K\NULL;{}$\6
\&{if} ${}(\\{line\_no}\I\\{tot\_lines}+\T{1}){}$\1\5
\&{return} ${}(\\{io\_errors}\MRL{{\OR}{\K}}\\{wrong\_number\_of\_lines});{}$\2%
\6
\&{if} ${}(\\{magic}\I\\{final\_magic}){}$\1\5
\&{return} ${}(\\{io\_errors}\MRL{{\OR}{\K}}\\{wrong\_checksum});{}$\2\6
\&{return} \\{io\_errors};\6
\4${}\}{}$\2\par
\fi

\M{40}There is also a less paranoid routine, \PB{\\{gb\_raw\_close}}, that
closes user-generated files. It simply closes the current file, if any,
and returns the value of the \PB{\\{magic}} checksum.

Example: The \PB{\\{restore\_graph}} subroutine in {\sc GB\_\,SAVE} uses
\PB{\\{gb\_raw\_open}} and \PB{\\{gb\_raw\_close}} to provide
system-independent input
that is almost as foolproof as the reading of standard GraphBase data.

\fi

\M{41}\B\D$\\{gb\_raw\_close}$ \5
\\{gb\_r\_close}\C{ for Procrustean external linkage }\par
\Y\B\4\X6:\.{gb\_io.h\,}\X${}\mathrel+\E{}$\6
\8\#\&{define} \\{gb\_raw\_close}\5\\{gb\_r\_close}\6
\&{extern} \&{long} \\{gb\_close}(\,);\C{ close a GraphBase data file; return 0
if OK }\6
\&{extern} \&{long} \\{gb\_raw\_close}(\,);\C{ close file and return the
checksum }\par
\fi

\M{42}\B\X12:External functions\X${}\mathrel+\E{}$\6
\1\1\&{long} \\{gb\_raw\_close}(\,)\2\2\6
${}\{{}$\1\6
\&{if} (\\{cur\_file})\5
${}\{{}$\1\6
\\{fclose}(\\{cur\_file});\6
${}\\{more\_data}\K\\{buffer}[\T{0}]\K\T{0};{}$\6
${}\\{cur\_pos}\K\\{buffer};{}$\6
${}\\{cur\_file}\K\NULL;{}$\6
\4${}\}{}$\2\6
\&{return} \\{magic};\6
\4${}\}{}$\2\par
\fi

\N{1}{43}Index. Here is a list that shows where the identifiers of this program
are
defined and used.
\fi

\inx
\fin
\con
