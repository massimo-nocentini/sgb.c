\input cwebmac
% This file is part of the Stanford GraphBase (c) Stanford University 1993
% This material goes at the beginning of all Stanford GraphBase CWEB files

\def\topofcontents{
  \leftline{\sc\today\ at \hours}\bigskip\bigskip
  \centerline{\titlefont\title}}

\font\ninett=cmtt9
\def\botofcontents{\vskip 0pt plus 1filll
    \ninerm\baselineskip10pt
    \noindent\copyright\ 1993 Stanford University
    \bigskip\noindent
    This file may be freely copied and distributed, provided that
    no changes whatsoever are made. All users are asked to help keep
    the Stanford GraphBase files consistent and ``uncorrupted,''
    identical everywhere in the world. Changes are permissible only
    if the modified file is given a new name, different from the names of
    existing files in the Stanford GraphBase, and only if the modified file is
    clearly identified as not being part of that GraphBase.
    (The {\ninett CWEB} system has a ``change file'' facility by
    which users can easily make minor alterations without modifying
    the master source files in any way. Everybody is supposed to use
    change files instead of changing the files.)
    The author has tried his best to produce correct and useful programs,
    in order to help promote computer science research,
    but no warranty of any kind should be assumed.
    \smallskip\noindent
    Preliminary work on the Stanford GraphBase project
    was supported in part by National Science
    Foundation grant CCR-86-10181.}

\def\prerequisite#1{\def\startsection{\noindent
    Important: Before reading {\sc\title},
    please read or at least skim the program for {\sc#1}.\bigskip
    \let\startsection=\stsec\stsec}}
\def\prerequisites#1#2{\def\startsection{\noindent
    Important: Before reading {\sc\title}, please read
    or at least skim the programs for {\sc#1} and {\sc#2}.\bigskip
    \let\startsection=\stsec\stsec}}



\def\title{GB\_\,LISA}

\prerequisites{GB\_\,GRAPH}{GB\_\,IO}

\N{1}{1}Introduction. This GraphBase module contains the \PB{\\{lisa}}
subroutine,
which creates rectangular matrices of data based on Leonardo da Vinci's
{\sl Gioconda\/} (aka Mona Lisa). It also contains the \PB{\\{plane\_lisa}}
subroutine, which constructs undirected planar graphs based on \PB{\\{lisa}},
and the \PB{\\{bi\_lisa}} subroutine, which constructs undirected bipartite
graphs.
Another example of the use of \PB{\\{lisa}} can be
found in the demo program {\sc ASSIGN\_LISA}.

\Y\B\4\D$\\{plane\_lisa}$ \5
\\{p\_lisa}\C{ abbreviation for Procrustean external linkage }\par
\Y\B\4\X1:\.{gb\_lisa.h\,}\X${}\E{}$\6
\8\#\&{define} \\{plane\_lisa}\5\\{p\_lisa}\6
\&{extern} \&{long} ${}{*}\\{lisa}(\,);{}$\6
\&{extern} \&{Graph} ${}{*}\\{plane\_lisa}(\,);{}$\6
\&{extern} \&{Graph} ${}{*}\\{bi\_lisa}(\,){}$;\par
\As3\ET25.\fi

\M{2}The subroutine call \PB{$\\{lisa}(\|m,\|n,\|d,\\{m0},\\{m1},\\{n0},\\{n1},%
\\{d0},\\{d1},\\{area})$}
constructs an $m\times n$ matrix of integers in the range
$[0\,.\,.\,d\mskip1mu]$,
based on the information in \.{lisa.dat}. Storage space for the matrix is
allocated in the memory area called \PB{\\{area}}, using the normal GraphBase
conventions explained in {\sc GB\_\,GRAPH}.
The entries of the matrix can be regarded as pixel data, with
0~representing black and $d$~representing white, and with intermediate
values representing shades of gray.

The data in \.{lisa.dat} has 360 rows and 250 columns. The rows are numbered
0 to 359 from top to bottom, and the columns are numbered 0 to 249 from left
to right. The output of \PB{\\{lisa}} is generated from a rectangular section
of the picture consisting of \PB{$\\{m1}-\\{m0}$} rows and \PB{$\\{n1}-\\{n0}$}
columns; more
precisely, \PB{\\{lisa}} uses the data in positions $(k,l)$ for
\PB{$\\{m0}\Z\|k<\\{m1}$} and \PB{$\\{n0}\Z\|l<\\{n1}$}.

One way to understand the process of mapping \PB{$\|M\K\\{m1}-\\{m0}$} rows and
\PB{$\|N\K\\{n1}-\\{n0}$}
columns of input into \PB{\|m}~rows and \PB{\|n}~columns of output is to
imagine
a giant matrix of $mM$ rows and $nN$ columns in which the original input
data has been replicated as an $M\times N$ array of submatrices of
size $m\times n$; each of the submatrices contains $mn$ identical pixel
values. We can also regard the giant matrix as an $m\times n$ array of
submatrices of size $M\times N$. The pixel values to be output are obtained
by averaging the $M_{}N$ pixel values in the submatrices of this second
interpretation.

More precisely, the output pixel value in a given row and column is obtained
in two steps. First we sum the $M_{}N$ entries in the corresponding submatrix
of the giant matrix, obtaining a value $D$ between 0 and~$255M_{}N$. Then we
scale the value~$D$ linearly into the desired final range
$[0\,.\,.\,d\mskip1mu]$ by
setting the result to~0 if \PB{$\|D<\\{d0}$}, to~$d$ if \PB{$\|D\G\\{d1}$}, and
to
$\lfloor d(D-\PB{\\{d0}})/(\PB{\\{d1}}-\PB{\\{d0}})\rfloor$ if \PB{$\\{d0}\Z%
\|D<\\{d1}$}.

\Y\B\4\D$\.{MAX\_M}$ \5
\T{360}\C{ the total number of rows of input data }\par
\B\4\D$\.{MAX\_N}$ \5
\T{250}\C{ the total number of columns of input data }\par
\B\4\D$\.{MAX\_D}$ \5
\T{255}\C{ maximum pixel value in the input data }\par
\fi

\M{3}Default parameter values are automatically substituted when \PB{\|m}, \PB{%
\|n}, \PB{\|d},
\PB{\\{m1}}, \PB{\\{n1}}, and/or \PB{\\{d1}} are given as~0: If \PB{$\\{m1}\K%
\T{0}$} or \PB{$\\{m1}>\T{360}$},
\PB{\\{m1}}~is changed to 360; if \PB{$\\{n1}\K\T{0}$} or \PB{$\\{n1}>%
\T{250}$}, \PB{\\{n1}}~is
changed to~250. Then if \PB{\|m} is zero, it is changed
to~\PB{$\\{m1}-\\{m0}$}; if \PB{\|n} is zero, it is changed to~\PB{$\\{n1}-%
\\{n0}$}.
If \PB{\|d} is zero, it is changed to~255.
If \PB{\\{d1}} is zero, it is changed to \PB{$\T{255}(\\{m1}-\\{m0})(\\{n1}-%
\\{n0})$}.
After these substitutions have been made, the parameters must satisfy
$$\hbox{\PB{$\\{m0}<\\{m1}$}, \qquad\PB{$\\{n0}<\\{n1}$}, \qquad and \qquad %
\PB{$\\{d0}<\\{d1}$}.}$$

Examples: The call \PB{$\hbox{\\{lisa\_pix}}\K$ $\\{lisa}(\T{0},\T{0},\T{0},%
\T{0},\T{0},\T{0},\T{0},\T{0},\T{0},\\{area})$}
is equivalent to the call
\PB{$\hbox{\\{lisa\_pix}}\K$ $\\{lisa}(\T{360},\T{250},\T{255},\T{0},\T{360},%
\T{0},\T{250},\T{0},\T{255}*\T{360}*\T{250},\\{area})$};
this special case delivers the original \.{lisa.dat} data as a
$360\times250$ array of integers in the range $[0\,.\,.\,255]$. You
can access the pixel in row~$k$ and column~$l$ by writing
$$\hbox{\PB{${*}(\hbox{\\{lisa\_pix}}+\|n*\|k+\|l)$}}\,,$$ where \PB{\|n} in
this case is
250. A square array extracted from the top part of the picture,
leaving out Mona's hands at the bottom, can be obtained by calling
\PB{$\\{lisa}(\T{250},\T{250},\T{255},\T{0},\T{250},\T{0},\T{250},\T{0},\T{0},%
\\{area})$}.

The call \PB{$\\{lisa}(\T{36},\T{25},\T{25500},\T{0},\T{0},\T{0},\T{0},\T{0},%
\T{0},\\{area})$} gives a $36\times25$ array
of pixel values in the range $[0\,.\,.\,25500]$, obtained by summing
$10\times10$ subsquares of the original data.

The call \PB{$\\{lisa}(\T{100},\T{100},\T{100},\T{0},\T{0},\T{0},\T{0},\T{0},%
\T{0},\\{area})$} gives a $100\times100$ array
of pixel values in the range $[0\,.\,.\,100]$; in this case the original
data is effectively broken into subpixels and averaged appropriately.
Notice that each output pixel in this example comes from 3.6 input
rows and 2.5 input columns; therefore the image is being distorted
(compressed vertically). However, our GraphBase applications are generally
interested more in combinatorial test data, not in images per~se.
If \PB{$(\\{m1}-\\{m0})/\|m\K(\\{n1}-\\{n0})/\|n$}, the output of \PB{\\{lisa}}
will represent ``square
pixels.'' But if \PB{$(\\{m1}-\\{m0})/\|m<(\\{n1}-\\{n0})/\|n$}, a halftone
generated from the
output will be compressed in the horizontal dimension; if
\PB{$(\\{m1}-\\{m0})/\|m>(\\{n1}-\\{n0})/\|n$}, it will be compressed in the
vertical dimension.

If you want to reduce the original image to binary data, with the value~0
wherever the original pixels are less than some threshold value~\PB{\|t}
and the value~1 whenever they are \PB{\|t} or more, call
\PB{$\\{lisa}(\|m,\|n,\T{1},\\{m0},\\{m1},\\{n0},\\{n1},\hbox{}\penalty0{}%
\T{0},\|t*(\\{m1}-\\{m0})*(\\{n1}-\\{n0}),\\{area})$}.

The subroutine call \PB{$\\{lisa}(\T{1000},\T{1000},\T{255},\T{0},\T{250},%
\T{0},\T{250},\T{0},\T{0},\\{area})$} produces a
million pixels from the upper part of the original image. This matrix
contains more entries than the original data in \.{lisa.dat}, but of course
it is not any more accurate; it has simply been obtained by linear
interpolation---in fact, by replicating the original
data in $4\times4$ subarrays.

Mona Lisa's famous smile appears in the $16\times32$ subarray defined by
\PB{$\\{m0}\K\T{94}$}, \PB{$\\{m1}\K\T{110}$}, \PB{$\\{n0}\K\T{97}$}, \PB{$%
\\{n1}\K\T{129}$}. The \PB{\\{smile}} macro makes this
easily accessible. (See also \PB{\\{eyes}}.)

A string \PB{\\{lisa\_id}} is constructed, showing the actual parameter values
used by \PB{\\{lisa}} after defaults have been supplied.
The \PB{\\{area}} parameter is omitted from this string.

\Y\B\4\X1:\.{gb\_lisa.h\,}\X${}\mathrel+\E{}$\6
\8\#\&{define} ${}\\{smile}\hbox{\quad}\\{m0}\K\T{94},\39\\{m1}\K\T{110},\39%
\\{n0}\K\T{97},\39\\{n1}\K{}$\T{129}\C{ $16\times32$ }\6
\8\#\&{define} ${}\\{eyes}\hbox{\quad}\\{m0}\K\T{61},\39\\{m1}\K\T{80},\39%
\\{n0}\K\T{91},\39\\{n1}\K{}$\T{140}\C{ $20\times50$ }\6
\&{extern} \&{char} \\{lisa\_id}[\,];\par
\fi

\M{4}\B\X4:Global variables\X${}\E{}$\6
\&{char} \\{lisa\_id}[\,]${}\K\.{"lisa(360,250,999999}\)%
\.{9999,359,360,249,250}\)\.{,9999999999,99999999}\)\.{99)"}{}$;\par
\U6.\fi

\M{5}If the \PB{\\{lisa}} routine encounters a problem, it returns \PB{$\NULL$}
(\.{NULL}), after putting a nonzero number into the external variable
\PB{\\{panic\_code}}. This code number identifies the type of failure.
Otherwise \PB{\\{lisa}} returns a pointer to the newly created array. (The
external variable \PB{\\{panic\_code}} is defined in {\sc GB\_\,GRAPH}.)

\Y\B\4\D$\\{panic}(\|c)$ \5
${}\{{}$\5
\1${}\\{panic\_code}\K\|c{}$;\5
${}\\{gb\_trouble\_code}\K\T{0}{}$;\5
\&{return} ${}\NULL{}$;\5
${}\}{}$\2\par
\fi

\M{6}The \CEE/ file \.{gb\_lisa.c} begins as follows. (Other subroutines
come later.)

\Y\B\8\#\&{include} \.{"gb\_io.h"}\C{ we will use the {\sc GB\_\,IO} routines
for input }\6
\8\#\&{include} \.{"gb\_graph.h"}\C{ we will use the {\sc GB\_\,GRAPH} data
structures }\6
\ATH\7
\X4:Global variables\X\6
\X16:Private variables\X\6
\X15:Private subroutines\X\7
\1\1\&{long} ${}{*}\\{lisa}(\|m,\39\|n,\39\|d,\39\\{m0},\39\\{m1},\39\\{n0},\39%
\\{n1},\39\\{d0},\39\\{d1},\39\\{area}){}$\6
\&{unsigned} \&{long} \|m${},\39\|n{}$;\C{ number of rows and columns desired }%
\6
\&{unsigned} \&{long} \|d;\C{ maximum pixel value desired }\6
\&{unsigned} \&{long} \\{m0}${},\39\\{m1}{}$;\C{ input will be from rows $[\PB{%
\\{m0}}\,.\,.\,\PB{\\{m1}})$ }\6
\&{unsigned} \&{long} \\{n0}${},\39\\{n1}{}$;\C{ and from columns $[\PB{\\{n0}}%
\,.\,.\,\PB{\\{n1}})$ }\6
\&{unsigned} \&{long} \\{d0}${},\39\\{d1}{}$;\C{ lower and upper threshold of
raw pixel scores }\6
\&{Area} \\{area};\C{ where to allocate the matrix that will be output }\2\2\6
${}\{{}$\5
\1\X7:Local variables for \PB{\\{lisa}}\X\7
\X8:Check the parameters and adjust them for defaults\X;\6
\X9:Allocate the matrix\X;\6
\X10:Read \.{lisa.dat} and map it to the desired output form\X;\6
\&{return} \\{matx};\6
\4${}\}{}$\2\par
\fi

\M{7}\B\X7:Local variables for \PB{\\{lisa}}\X${}\E{}$\6
\&{long} ${}{*}\\{matx}\K\NULL{}$;\C{ the matrix constructed by \PB{\\{lisa}} }%
\6
\&{register} \&{long} \|k${},\39\|l{}$;\C{ the current row and column of output
}\6
\&{register} \&{long} \|i${},\39\|j{}$;\C{ all-purpose indices }\6
\&{long} \\{cap\_M}${},\39\\{cap\_N}{}$;\C{ \PB{$\\{m1}-\\{m0}$} and \PB{$%
\\{n1}-\\{n0}$}, dimensions of the input }\6
\&{long} \\{cap\_D};\C{ \PB{$\\{d1}-\\{d0}$}, scale factor }\par
\As11\ET14.
\U6.\fi

\M{8}\B\X8:Check the parameters and adjust them for defaults\X${}\E{}$\6
\&{if} ${}(\\{m1}\E\T{0}\V\\{m1}>\.{MAX\_M}){}$\1\5
${}\\{m1}\K\.{MAX\_M};{}$\2\6
\&{if} ${}(\\{m1}\Z\\{m0}){}$\1\5
${}\\{panic}(\\{bad\_specs}+\T{1}){}$;\C{ \PB{\\{m0}} must be less than \PB{%
\\{m1}} }\2\6
\&{if} ${}(\\{n1}\E\T{0}\V\\{n1}>\.{MAX\_N}){}$\1\5
${}\\{n1}\K\.{MAX\_N};{}$\2\6
\&{if} ${}(\\{n1}\Z\\{n0}){}$\1\5
${}\\{panic}(\\{bad\_specs}+\T{2}){}$;\C{ \PB{\\{n0}} must be less than \PB{%
\\{n1}} }\2\6
${}\\{cap\_M}\K\\{m1}-\\{m0}{}$;\5
${}\\{cap\_N}\K\\{n1}-\\{n0};{}$\6
\&{if} ${}(\|m\E\T{0}){}$\1\5
${}\|m\K\\{cap\_M};{}$\2\6
\&{if} ${}(\|n\E\T{0}){}$\1\5
${}\|n\K\\{cap\_N};{}$\2\6
\&{if} ${}(\|d\E\T{0}){}$\1\5
${}\|d\K\.{MAX\_D};{}$\2\6
\&{if} ${}(\\{d1}\E\T{0}){}$\1\5
${}\\{d1}\K\.{MAX\_D}*\\{cap\_M}*\\{cap\_N};{}$\2\6
\&{if} ${}(\\{d1}\Z\\{d0}){}$\1\5
${}\\{panic}(\\{bad\_specs}+\T{3}){}$;\C{ \PB{\\{d0}} must be less than \PB{%
\\{d1}} }\2\6
\&{if} ${}(\\{d1}\G\T{\^80000000}){}$\1\5
${}\\{panic}(\\{bad\_specs}+\T{4}){}$;\C{ \PB{\\{d1}} must be less than
$2^{31}$ }\2\6
${}\\{cap\_D}\K\\{d1}-\\{d0};{}$\6
${}\\{sprintf}(\\{lisa\_id},\39\.{"lisa(\%lu,\%lu,\%lu,\%l}\)\.{u,\%lu,\%lu,%
\%lu,\%lu,\%l}\)\.{u)"},\39\|m,\39\|n,\39\|d,\39\\{m0},\39\\{m1},\39\\{n0},\39%
\\{n1},\39\\{d0},\39\\{d1}){}$;\par
\U6.\fi

\M{9}\B\X9:Allocate the matrix\X${}\E{}$\6
$\\{matx}\K\\{gb\_typed\_alloc}(\|m*\|n,\39\&{long},\39\\{area});{}$\6
\&{if} (\\{gb\_trouble\_code})\1\5
${}\\{panic}(\\{no\_room}+\T{1}){}$;\C{ no room for the output data }\2\par
\U6.\fi

\M{10}\B\X10:Read \.{lisa.dat} and map it to the desired output form\X${}\E{}$\6
\X19:Open the data file, skipping unwanted rows at the beginning\X;\6
\X13:Generate the $m$ rows of output\X;\6
\X20:Close the data file, skipping unwanted rows at the end\X;\par
\U6.\fi

\N{1}{11}Elementary image processing.
As mentioned in the introduction, we can visualize the input as a giant
$mM\times nN$ matrix, into which an $M\times N$ image is placed by replication
of pixel values, and from which an $m\times n$ image is derived by summation
of pixel values and subsequent scaling. Here \PB{$\|M\K\\{m1}-\\{m0}$} and %
\PB{$\|N\K\\{n1}-\\{n0}$}.

Let $(\kappa,\lambda)$ be a position in the giant matrix, where $0\le\kappa<mM$
and $0\le\lambda<nN$. The corresponding indices of the input image are
then $\bigl(\PB{\\{m0}}+\lfloor\kappa/m\rfloor, \PB{\\{n0}}+\lfloor\lambda/n%
\rfloor\bigr)$,
and the corresponding indices of the output image are
$\bigl(\lfloor\kappa/M\rfloor,\lfloor\lambda/N\rfloor\bigr)$. Our main job
is to compute the sum of all pixel values that lie in each given row~\PB{\|k}
and column~\PB{\|l} of the output image. Many elements are repeated in
the sum, so we want to use multiplication instead of simple addition whenever
possible.

For example, let's consider the inner loop first, the loop on $l$ and
$\lambda$.  Suppose $n=3$, and suppose the input pixels in the current
row of interest are $\langle a_0,\ldots,a_{N-1}\rangle$. Then if $N=3$,
we want to compute the output pixels $\langle3a_0,3a_1,3a_2\rangle$;
if $N=4$, we want to compute
$\langle3a_0+a_1,2a_1+2a_2,a_2+3a_3\rangle$; if $N=2$, we want to
compute $\langle2a_0,a_0+a_1,2a_1\rangle$. The logic for doing this
computation with the proper timing can be expressed conveniently in
terms of four local variables:

\Y\B\4\X7:Local variables for \PB{\\{lisa}}\X${}\mathrel+\E{}$\6
\&{long} ${}{*}\\{cur\_pix}{}$;\C{ current position within \PB{\\{in\_row}} }\6
\&{long} \\{lambda};\C{ right boundary in giant for the input pixel in \PB{%
\\{cur\_pix}} }\6
\&{long} \\{lam};\C{ the first giant column not yet used in the current row }\6
\&{long} \\{next\_lam};\C{ right boundary in giant for the output pixel in
column~\PB{\|l} }\par
\fi

\M{12}\B\X12:Process one row of pixel sums, multiplying them by~\PB{\|f}\X${}%
\E{}$\6
$\\{lambda}\K\|n{}$;\5
${}\\{cur\_pix}\K\\{in\_row}+\\{n0};{}$\6
\&{for} ${}(\|l\K\\{lam}\K\T{0};{}$ ${}\|l<\|n;{}$ ${}\|l\PP){}$\5
${}\{{}$\5
\1\&{register} \&{long} \\{sum}${}\K\T{0};{}$\7
${}\\{next\_lam}\K\\{lam}+\\{cap\_N};{}$\6
\&{do}\5
${}\{{}$\5
\1\&{register} \&{long} \\{nl};\C{ giant column where something new might
happen }\7
\&{if} ${}(\\{lam}\G\\{lambda}){}$\1\5
${}\\{cur\_pix}\PP,\39\\{lambda}\MRL{+{\K}}\|n;{}$\2\6
\&{if} ${}(\\{lambda}<\\{next\_lam}){}$\1\5
${}\\{nl}\K\\{lambda};{}$\2\6
\&{else}\1\5
${}\\{nl}\K\\{next\_lam};{}$\2\6
${}\\{sum}\MRL{+{\K}}(\\{nl}-\\{lam})*({*}\\{cur\_pix});{}$\6
${}\\{lam}\K\\{nl};{}$\6
\4${}\}{}$\5
\2\5
\&{while} ${}(\\{lam}<\\{next\_lam});{}$\6
${}{*}(\\{out\_row}+\|l)\MRL{+{\K}}\|f*\\{sum};{}$\6
\4${}\}{}$\2\par
\U13.\fi

\M{13}The outer loop (on $k$ and $\kappa$) is similar but slightly more
complicated, because it deals with a vector of sums instead of a single
sum and because it must invoke the input routine when we're done
with a row of input data.

%Generate them rows...
\Y\B\4\X13:Generate the $m$ rows of output\X${}\E{}$\6
$\\{kappa}\K\T{0};{}$\6
${}\\{out\_row}\K\\{matx};{}$\6
\&{for} ${}(\|k\K\\{kap}\K\T{0};{}$ ${}\|k<\|m;{}$ ${}\|k\PP){}$\5
${}\{{}$\1\6
\&{for} ${}(\|l\K\T{0};{}$ ${}\|l<\|n;{}$ ${}\|l\PP){}$\1\5
${}{*}(\\{out\_row}+\|l)\K\T{0}{}$;\C{ clear the vector of sums }\2\6
${}\\{next\_kap}\K\\{kap}+\\{cap\_M};{}$\6
\&{do}\5
${}\{{}$\5
\1\&{register} \&{long} \\{nk};\C{ giant row where something new might happen }%
\7
\&{if} ${}(\\{kap}\G\\{kappa}){}$\5
${}\{{}$\1\6
\X21:Read a row of input into \PB{\\{in\_row}}\X;\6
${}\\{kappa}\MRL{+{\K}}\|m;{}$\6
\4${}\}{}$\2\6
\&{if} ${}(\\{kappa}<\\{next\_kap}){}$\1\5
${}\\{nk}\K\\{kappa};{}$\2\6
\&{else}\1\5
${}\\{nk}\K\\{next\_kap};{}$\2\6
${}\|f\K\\{nk}-\\{kap};{}$\6
\X12:Process one row of pixel sums, multiplying them by~\PB{\|f}\X;\6
${}\\{kap}\K\\{nk};{}$\6
\4${}\}{}$\5
\2\5
\&{while} ${}(\\{kap}<\\{next\_kap});{}$\6
\&{for} ${}(\|l\K\T{0};{}$ ${}\|l<\|n;{}$ ${}\|l\PP,\39\\{out\_row}\PP{}$)\C{
note that \PB{\\{out\_row}} will advance by~\PB{\|n} }\1\6
\X18:Scale the sum found in \PB{${*}\\{out\_row}$}\X;\2\6
\4${}\}{}$\2\par
\U10.\fi

\M{14}\B\X7:Local variables for \PB{\\{lisa}}\X${}\mathrel+\E{}$\6
\&{long} \\{kappa};\C{ bottom boundary in giant for the input pixels in \PB{%
\\{in\_row}} }\6
\&{long} \\{kap};\C{ the first giant row not yet used }\6
\&{long} \\{next\_kap};\C{ bottom boundary in giant for the output pixel in
row~\PB{\|k} }\6
\&{long} \|f;\C{ factor by which current input sums should be replicated }\6
\&{long} ${}{*}\\{out\_row}{}$;\C{ current position in \PB{\\{matx}} }\par
\fi

\N{1}{15}Integer scaling.
Here's a general-purpose routine to compute $\lfloor na/b\rfloor$ exactly
without risking integer overflow, given integers $n\ge0$ and $0<a\le b$.
The idea is to solve the problem first for $n/2$, if $n$ is too large.

We are careful to precompute values so that integer overflow cannot
occur when $b$ is very large.

\Y\B\4\D$\\{el\_gordo}$ \5
\T{\^7fffffff}\C{ $2^{31}-1$, the largest single-precision \PB{\&{long}} }\par
\Y\B\4\X15:Private subroutines\X${}\E{}$\6
\1\1\&{static} \&{long} ${}\\{na\_over\_b}(\|n,\39\|a,\39\|b){}$\6
\&{long} \|n${},\39\|a,\39\|b;\2\2{}$\6
${}\{{}$\5
\1\&{long} \\{nmax}${}\K\\{el\_gordo}/\|a{}$;\C{ the largest $n$ such that $na$
doesn't overflow }\6
\&{register} \&{long} \|r${},\39\|k,\39\|q,\39\\{br};{}$\6
\&{long} \\{a\_thresh}${},\39\\{b\_thresh};{}$\7
\&{if} ${}(\|n\Z\\{nmax}){}$\1\5
\&{return} ${}(\|n*\|a)/\|b;{}$\2\6
${}\\{a\_thresh}\K\|b-\|a;{}$\6
${}\\{b\_thresh}\K(\|b+\T{1})\GG\T{1}{}$;\C{ $\lceil b/2\rceil$ }\6
${}\|k\K\T{0};{}$\6
\&{do}\5
${}\{{}$\5
\1${}\\{bit}[\|k]\K\|n\AND\T{1}{}$;\C{ save the least significant bit of $n$ }\6
${}\|n\MRL{{\GG}{\K}}\T{1}{}$;\C{ and shift it out }\6
${}\|k\PP;{}$\6
\4${}\}{}$\5
\2\5
\&{while} ${}(\|n>\\{nmax});{}$\6
${}\|r\K\|n*\|a{}$;\5
${}\|q\K\|r/\|b{}$;\5
${}\|r\K\|r-\|q*\|b;{}$\6
\X17:Maintain quotient \PB{\|q} and remainder \PB{\|r} while increasing \PB{%
\|n} back to its original value $2^kn+(\PB{\\{bit}}[k-1]\ldots \PB{%
\\{bit}}[0])_2$\X;\6
\&{return} \|q;\6
\4${}\}{}$\2\par
\A32.
\U6.\fi

\M{16}\B\X16:Private variables\X${}\E{}$\6
\&{static} \&{long} \\{bit}[\T{30}];\C{ bits shifted out of \PB{\|n} }\par
\A22.
\U6.\fi

\M{17}\B\X17:Maintain quotient \PB{\|q} and remainder \PB{\|r} while increasing
\PB{\|n} back to its original value $2^kn+(\PB{\\{bit}}[k-1]\ldots \PB{%
\\{bit}}[0])_2$\X${}\E{}$\6
\&{do}\5
${}\{{}$\5
\1${}\|k\MM{}$;\5
${}\|q\MRL{{\LL}{\K}}\T{1};{}$\6
\&{if} ${}(\|r<\\{b\_thresh}){}$\1\5
${}\|r\MRL{{\LL}{\K}}\T{1};{}$\2\6
\&{else}\1\5
${}\|q\PP,\39\\{br}\K(\|b-\|r)\LL\T{1},\39\|r\K\|b-\\{br};{}$\2\6
\&{if} (\\{bit}[\|k])\5
${}\{{}$\1\6
\&{if} ${}(\|r<\\{a\_thresh}){}$\1\5
${}\|r\MRL{+{\K}}\|a;{}$\2\6
\&{else}\1\5
${}\|q\PP,\39\|r\MRL{-{\K}}\\{a\_thresh};{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\5
\2\5
\&{while} (\|k);\par
\U15.\fi

\M{18}\B\X18:Scale the sum found in \PB{${*}\\{out\_row}$}\X${}\E{}$\6
\&{if} ${}({*}\\{out\_row}\Z\\{d0}){}$\1\5
${}{*}\\{out\_row}\K\T{0};{}$\2\6
\&{else} \&{if} ${}({*}\\{out\_row}\G\\{d1}){}$\1\5
${}{*}\\{out\_row}\K\|d;{}$\2\6
\&{else}\1\5
${}{*}\\{out\_row}\K\\{na\_over\_b}(\|d,\39{*}\\{out\_row}-\\{d0},\39\\{cap%
\_D}){}$;\2\par
\U13.\fi

\N{1}{19}Input data format.
The file \.{lisa.dat} contains 360 rows of pixel data, and each row
appears on five consecutive lines of the file. The first four lines contain
the data for 60 pixels; each sequence of four pixels is represented by five
radix-85 digits, using the \PB{\\{icode}} mapping of {\sc GB\_\,IO}.
The fifth and final line of each row contains $4+4+2=10$ more pixels,
represented as $5+5+3$ radix-85 digits.

\Y\B\4\X19:Open the data file, skipping unwanted rows at the beginning\X${}%
\E{}$\6
\&{if} ${}(\\{gb\_open}(\.{"lisa.dat"})\I\T{0}){}$\1\5
\\{panic}(\\{early\_data\_fault});\C{ couldn't open the file; \PB{\\{io%
\_errors}} tells why }\2\6
\&{for} ${}(\|i\K\T{0};{}$ ${}\|i<\\{m0};{}$ ${}\|i\PP){}$\1\6
\&{for} ${}(\|j\K\T{0};{}$ ${}\|j<\T{5};{}$ ${}\|j\PP){}$\1\5
\\{gb\_newline}(\,);\C{ ignore one row of data }\2\2\par
\U10.\fi

\M{20}\B\X20:Close the data file, skipping unwanted rows at the end\X${}\E{}$\6
\&{for} ${}(\|i\K\\{m1};{}$ ${}\|i<\.{MAX\_M};{}$ ${}\|i\PP){}$\1\6
\&{for} ${}(\|j\K\T{0};{}$ ${}\|j<\T{5};{}$ ${}\|j\PP){}$\1\5
\\{gb\_newline}(\,);\C{ ignore one row of data }\2\2\6
\&{if} ${}(\\{gb\_close}(\,)\I\T{0}){}$\1\5
\\{panic}(\\{late\_data\_fault});\C{ checksum or other failure in data file;
see \PB{\\{io\_errors}} }\2\par
\U10.\fi

\M{21}\B\X21:Read a row of input into \PB{\\{in\_row}}\X${}\E{}$\6
${}\{{}$\5
\1\&{register} \&{long} \\{dd};\7
\&{for} ${}(\|j\K\T{15},\39\\{cur\_pix}\K{\AND}\\{in\_row}[\T{0}];{}$  ; ${}%
\\{cur\_pix}\MRL{+{\K}}\T{4}){}$\5
${}\{{}$\1\6
${}\\{dd}\K\\{gb\_digit}(\T{85}){}$;\5
${}\\{dd}\K\\{dd}*\T{85}+\\{gb\_digit}(\T{85}){}$;\5
${}\\{dd}\K\\{dd}*\T{85}+\\{gb\_digit}(\T{85});{}$\6
\&{if} ${}(\\{cur\_pix}\E{\AND}\\{in\_row}[\.{MAX\_N}-\T{2}]){}$\1\5
\&{break};\2\6
${}\\{dd}\K\\{dd}*\T{85}+\\{gb\_digit}(\T{85}){}$;\5
${}\\{dd}\K\\{dd}*\T{85}+\\{gb\_digit}(\T{85});{}$\6
${}{*}(\\{cur\_pix}+\T{3})\K\\{dd}\AND\T{\^ff}{}$;\5
${}\\{dd}\K(\\{dd}\GG\T{8})\AND\T{\^ffffff};{}$\6
${}{*}(\\{cur\_pix}+\T{2})\K\\{dd}\AND\T{\^ff}{}$;\5
${}\\{dd}\MRL{{\GG}{\K}}\T{8};{}$\6
${}{*}(\\{cur\_pix}+\T{1})\K\\{dd}\AND\T{\^ff}{}$;\5
${}{*}\\{cur\_pix}\K\\{dd}\GG\T{8};{}$\6
\&{if} ${}(\MM\|j\E\T{0}){}$\1\5
${}\\{gb\_newline}(\,),\39\|j\K\T{15};{}$\2\6
\4${}\}{}$\2\6
${}{*}(\\{cur\_pix}+\T{1})\K\\{dd}\AND\T{\^ff}{}$;\5
${}{*}\\{cur\_pix}\K\\{dd}\GG\T{8}{}$;\5
\\{gb\_newline}(\,);\6
\4${}\}{}$\2\par
\U13.\fi

\M{22}\B\X16:Private variables\X${}\mathrel+\E{}$\6
\&{static} \&{long} \\{in\_row}[\.{MAX\_N}];\par
\fi

\N{1}{23}Planar graphs. We can obtain a large family of planar graphs based on
digitizations of Mona Lisa by using the following simple scheme: Each matrix
of pixels defines a set of connected regions containing pixels of the same
value. (Two pixels are considered adjacent if they share an edge.)
These connected regions are taken to be vertices of an undirected graph;
two vertices are adjacent if the corresponding regions have at least
one pixel edge in common.

We can also state the construction another way. If we take any planar
graph and collapse two adjacent vertices, we obtain another planar
graph. Suppose we start with the planar graph having $mn$ vertices
$[k,l]$ for $0\le k<m$ and $0\le l<n$, where $[k,l]$ is adjacent to
$[k,l-1]$ when $l>0$ and to $[k-1,l]$ when $k>0$. Then we can attach
pixel values to each vertex, after which we can repeatedly collapse
adjacent vertices whose pixel values are equal. The resulting planar
graph is the same as the graph of connected regions that was described
in the previous paragraph.

The subroutine call \PB{$\\{plane\_lisa}(\|m,\|n,\|d,\\{m0},\\{m1},\\{n0},%
\\{n1},\\{d0},\\{d1})$} constructs
the planar graph associated with the digitization produced by \PB{\\{lisa}}.
The description of \PB{\\{lisa}}, given earlier, explains the significance of
parameters \PB{\|m}, \PB{\|n}, \PB{\|d}, \PB{\\{m0}}, \PB{\\{m1}}, \PB{\\{n0}},
\PB{\\{n1}}, \PB{\\{d0}}, and \PB{\\{d1}}. There will
be at most $mn$ vertices, and the graph will be simply an $m\times n$
grid unless \PB{\|d} is small enough to permit adjacent pixels to have
equal values. The graph will also become rather trivial if \PB{\|d} is
too small.

Utility fields \PB{\\{first\_pixel}} and \PB{\\{last\_pixel}} give, for each
vertex,
numbers of the form $k*n+l$, identifying the topmost/leftmost
and bottommost/rightmost positions $[k,l]$ in the region corresponding
to that vertex. Utility fields \PB{\\{matrix\_rows}} and \PB{\\{matrix\_cols}}
in
the \PB{\&{Graph}} record contain the values of \PB{\|m} and~\PB{\|n}; thus, in
particular,
the value of \PB{\|n} needed to decompose \PB{\\{first\_pixel}} and \PB{\\{last%
\_pixel}} into
individual coordinates can be found in \PB{$\|g\MG\\{matrix\_cols}$}.

The original pixel value of a vertex is placed into its \PB{\\{pixel\_value}}
utility field.

\Y\B\4\D$\\{pixel\_value}$ \5
$\|x.{}$\|I\par
\B\4\D$\\{first\_pixel}$ \5
$\|y.{}$\|I\par
\B\4\D$\\{last\_pixel}$ \5
$\|z.{}$\|I\par
\B\4\D$\\{matrix\_rows}$ \5
$\\{uu}.{}$\|I\par
\B\4\D$\\{matrix\_cols}$ \5
$\\{vv}.{}$\|I\par
\Y\B\1\1\&{Graph} ${}{*}\\{plane\_lisa}(\|m,\39\|n,\39\|d,\39\\{m0},\39\\{m1},%
\39\\{n0},\39\\{n1},\39\\{d0},\39\\{d1}){}$\6
\&{unsigned} \&{long} \|m${},\39\|n{}$;\C{ number of rows and columns desired }%
\6
\&{unsigned} \&{long} \|d;\C{ maximum value desired }\6
\&{unsigned} \&{long} \\{m0}${},\39\\{m1}{}$;\C{ input will be from rows $[\PB{%
\\{m0}}\,.\,.\,\PB{\\{m1}})$ }\6
\&{unsigned} \&{long} \\{n0}${},\39\\{n1}{}$;\C{ and from columns $[\PB{\\{n0}}%
\,.\,.\,\PB{\\{n1}})$ }\6
\&{unsigned} \&{long} \\{d0}${},\39\\{d1}{}$;\C{ lower and upper threshold of
raw pixel scores }\2\2\6
${}\{{}$\5
\1\X24:Local variables for \PB{\\{plane\_lisa}}\X\7
\\{init\_area}(\\{working\_storage});\6
\X26:Figure out the number of connected regions, \PB{\\{regs}}\X;\6
\X29:Set up a graph with \PB{\\{regs}} vertices\X;\6
\X30:Put the appropriate edges into the graph\X;\6
\4\\{trouble}:\5
\\{gb\_free}(\\{working\_storage});\6
\&{if} (\\{gb\_trouble\_code})\5
${}\{{}$\1\6
\\{gb\_recycle}(\\{new\_graph});\6
\\{panic}(\\{alloc\_fault});\C{ oops, we ran out of memory somewhere back there
}\6
\4${}\}{}$\2\6
\&{return} \\{new\_graph};\6
\4${}\}{}$\2\par
\fi

\M{24}\B\X24:Local variables for \PB{\\{plane\_lisa}}\X${}\E{}$\6
\&{Graph} ${}{*}\\{new\_graph}{}$;\C{ the graph constructed by \PB{\\{plane%
\_lisa}} }\6
\&{register} \&{long} \|j${},\39\|k,\39\|l{}$;\C{ all-purpose indices }\6
\&{Area} \\{working\_storage};\C{ tables needed while \PB{\\{plane\_lisa}} does
its thinking }\6
\&{long} ${}{*}\|a{}$;\C{ the matrix constructed by \PB{\\{lisa}} }\6
\&{long} \\{regs}${}\K\T{0}{}$;\C{ number of vertices generated so far }\par
\As27\ET31.
\U23.\fi

\M{25}\B\X1:\.{gb\_lisa.h\,}\X${}\mathrel+\E{}$\6
\8\#\&{define} ${}\\{pixel\_value}\hbox{\quad}\|x.{}$\|I\C{ definitions for the
header file }\6
\8\#\&{define} ${}\\{first\_pixel}\hbox{\quad}\|y.\|I{}$\6
\8\#\&{define} ${}\\{last\_pixel}\hbox{\quad}\|z.\|I{}$\6
\8\#\&{define} ${}\\{matrix\_rows}\hbox{\quad}\\{uu}.\|I{}$\6
\8\#\&{define} ${}\\{matrix\_cols}\hbox{\quad}\\{vv}.\|I{}$\par
\fi

\M{26}The following algorithm for counting the connected regions considers
the array elements \PB{$\|a[\|k,\|l]$} to be linearly ordered as they appear
in memory. Thus we can speak of the $n$ elements preceding a given
element \PB{$\|a[\|k,\|l]$}, if $k>0$; these are the elements \PB{$\|a[\|k,\|l-%
\T{1}]$}, \dots,
\PB{$\|a[\|k,\T{0}]$}, \PB{$\|a[\|k-\T{1},\|n-\T{1}]$}, \dots, \PB{$\|a[\|k-%
\T{1},\|l]$}. These $n$ elements appear
in $n$ different columns.

During the algorithm, we move through the array from bottom right
to top left, maintaining an auxiliary table $\langle f[0],\ldots,f[n-1]
\rangle$ with the following significance: Whenever two of the
$n$ elements preceding our current position $[k,l]$ are connected to
each other by a sequence of pixels with equal value, where the connecting
links do not involve pixels more than $n$ steps before our current
position, those elements will be linked together in the $f$ array.
More precisely, we will have $f[c_1]=c_2$, \dots, $f[c_{j-1}]=c_j$,
and $f[c_j]=c_j$, when there are $j$ equivalent elements in columns
$c_1$, \dots,~$c_j$. Here $c_1$ will be the ``last'' column and
$c_j$ the ``first,'' in wraparound order; each element with $f[c]\ne c$
points to an earlier element.

The main function of the \PB{\|f} table is to identify the topmost/leftmost
pixel of a region. If we are at position \PB{$[\|k,\|l]$} and if we find
$f[l]=l$
while $a[k-1,l]\ne a[k,l]$, there is no way to connect \PB{$[\|k,\|l]$} to
earlier positions, so we create a new vertex for it.

We also change the \PB{\|a} matrix, to facilitate another algorithm
below. If position \PB{$[\|k,\|l]$} is the topmost/leftmost pixel of a region,
we set \PB{$\|a[\|k,\|l]\K{-}\T{1}-\|a[\|k,\|l]$}; otherwise we set \PB{$\|a[%
\|k,\|l]\K\|f[\|l]$}, the column of
a preceding element belonging to the same region.

\Y\B\4\X26:Figure out the number of connected regions, \PB{\\{regs}}\X${}\E{}$\6
$\|a\K\\{lisa}(\|m,\39\|n,\39\|d,\39\\{m0},\39\\{m1},\39\\{n0},\39\\{n1},\39%
\\{d0},\39\\{d1},\39\\{working\_storage});{}$\6
\&{if} ${}(\|a\E\NULL){}$\1\5
\&{return} ${}\NULL{}$;\C{ \PB{\\{panic\_code}} has been set by \PB{\\{lisa}} }%
\2\6
${}\\{sscanf}(\\{lisa\_id},\39\.{"lisa(\%lu,\%lu,"},\39{\AND}\|m,\39{\AND}%
\|n){}$;\C{ adjust for defaults }\6
${}\|f\K\\{gb\_typed\_alloc}(\|n,\39{}$\&{unsigned} \&{long}${},\39\\{working%
\_storage});{}$\6
\&{if} ${}(\|f\E\NULL){}$\5
${}\{{}$\1\6
\\{gb\_free}(\\{working\_storage});\C{ recycle the \PB{\|a} matrix }\6
${}\\{panic}(\\{no\_room}+\T{2}){}$;\C{ there's no room for the \PB{\|f} vector
}\6
\4${}\}{}$\2\6
\X28:Pass over the \PB{\|a} matrix from bottom right to top left, looking for
the beginnings of connected regions\X;\par
\U23.\fi

\M{27}\B\X24:Local variables for \PB{\\{plane\_lisa}}\X${}\mathrel+\E{}$\6
\&{unsigned} \&{long} ${}{*}\|f{}$;\C{ beginning of array \PB{\|f};
         $f[j]$ is the column of an equivalent element }\6
\&{long} ${}{*}\\{apos}{}$;\C{ the location of \PB{$\|a[\|k,\|l]$} }\par
\fi

\M{28}We maintain a pointer \PB{\\{apos}} equal to \PB{${\AND}\|a[\|k,\|l]$},
so that
\PB{${*}(\\{apos}-\T{1})\K\|a[\|k,\|l-\T{1}]$} and \PB{${*}(\\{apos}-\|n)\K\|a[%
\|k-\T{1},\|l]$} when $l>0$ and $k>0$.

The loop that replaces $f[j]$ by $j$ can cause this algorithm to
take time $mn^2$. We could improve the worst case by using path
compression, but the extra complication is rarely worth the trouble.

\Y\B\4\X28:Pass over the \PB{\|a} matrix from bottom right to top left, looking
for the beginnings of connected regions\X${}\E{}$\6
\&{for} ${}(\|k\K\|m,\39\\{apos}\K\|a+\|n*(\|m+\T{1})-\T{1};{}$ ${}\|k\G%
\T{0};{}$ ${}\|k\MM){}$\1\6
\&{for} ${}(\|l\K\|n-\T{1};{}$ ${}\|l\G\T{0};{}$ ${}\|l\MM,\39\\{apos}\MM){}$\5
${}\{{}$\1\6
\&{if} ${}(\|k<\|m){}$\5
${}\{{}$\1\6
\&{if} ${}(\|k>\T{0}\W{*}(\\{apos}-\|n)\E{*}\\{apos}){}$\5
${}\{{}$\1\6
\&{for} ${}(\|j\K\|l;{}$ ${}\|f[\|j]\I\|j;{}$ ${}\|j\K\|f[\|j]){}$\1\5
;\C{ find the first element }\2\6
${}\|f[\|j]\K\|l{}$;\C{ link it to the new first element }\6
${}{*}\\{apos}\K\|l;{}$\6
\4${}\}{}$\5
\2\&{else} \&{if} ${}(\|f[\|l]\E\|l){}$\1\5
${}{*}\\{apos}\K{-}\T{1}-{*}\\{apos},\39\\{regs}\PP{}$;\C{ new region found }\2%
\6
\&{else}\1\5
${}{*}\\{apos}\K\|f[\|l];{}$\2\6
\4${}\}{}$\2\6
\&{if} ${}(\|k>\T{0}\W\|l<\|n-\T{1}\W{*}(\\{apos}-\|n)\E{*}(\\{apos}-\|n+%
\T{1})){}$\1\5
${}\|f[\|l+\T{1}]\K\|l;{}$\2\6
${}\|f[\|l]\K\|l;{}$\6
\4${}\}{}$\2\2\par
\U26.\fi

\M{29}\B\X29:Set up a graph with \PB{\\{regs}} vertices\X${}\E{}$\6
$\\{new\_graph}\K\\{gb\_new\_graph}(\\{regs});{}$\6
\&{if} ${}(\\{new\_graph}\E\NULL){}$\1\5
\\{panic}(\\{no\_room});\C{ out of memory before we're even started }\2\6
${}\\{sprintf}(\\{new\_graph}\MG\\{id},\39\.{"plane\_\%s"},\39\\{lisa\_id});{}$%
\6
${}\\{strcpy}(\\{new\_graph}\MG\\{util\_types},\39\.{"ZZZIIIZZIIZZZZ"});{}$\6
${}\\{new\_graph}\MG\\{matrix\_rows}\K\|m;{}$\6
${}\\{new\_graph}\MG\\{matrix\_cols}\K\|n{}$;\par
\U23.\fi

\M{30}Now we make another pass over the matrix, this time from top left
to bottom right. An auxiliary vector of length \PB{\|n} is once again
sufficient to tell us when one region is adjacent to a previous one.
In this case the vector is called \PB{\|u}, and it contains pointers to
the vertices in the $n$ positions before our current position.
We assume that a pointer to a \PB{\&{Vertex}} takes the same amount of
memory as an \PB{\&{unsigned} \&{long}}, hence \PB{\|u} can share the space
formerly
occupied by~\PB{\|f}; if this is not the case, a system-dependent
change should be made here.

The vertex names are simply integers, starting with 0.

\Y\B\4\X30:Put the appropriate edges into the graph\X${}\E{}$\6
$\\{regs}\K\T{0};{}$\6
${}\|u\K{}$(\&{Vertex} ${}{*}{*})\,\|f;{}$\6
\&{for} ${}(\|l\K\T{0};{}$ ${}\|l<\|n;{}$ ${}\|l\PP){}$\1\5
${}\|u[\|l]\K\NULL;{}$\2\6
\&{for} ${}(\|k\K\T{0},\39\\{apos}\K\|a,\39\\{aloc}\K\T{0};{}$ ${}\|k<\|m;{}$
${}\|k\PP){}$\1\6
\&{for} ${}(\|l\K\T{0};{}$ ${}\|l<\|n;{}$ ${}\|l\PP,\39\\{apos}\PP,\39\\{aloc}%
\PP){}$\5
${}\{{}$\1\6
${}\|w\K\|u[\|l];{}$\6
\&{if} ${}({*}\\{apos}<\T{0}){}$\5
${}\{{}$\1\6
${}\\{sprintf}(\\{str\_buf},\39\.{"\%ld"},\39\\{regs});{}$\6
${}\|v\K\\{new\_graph}\MG\\{vertices}+\\{regs};{}$\6
${}\|v\MG\\{name}\K\\{gb\_save\_string}(\\{str\_buf});{}$\6
${}\|v\MG\\{pixel\_value}\K{-}{*}\\{apos}-\T{1};{}$\6
${}\|v\MG\\{first\_pixel}\K\\{aloc};{}$\6
${}\\{regs}\PP;{}$\6
\4${}\}{}$\5
\2\&{else}\1\5
${}\|v\K\|u[{*}\\{apos}];{}$\2\6
${}\|u[\|l]\K\|v;{}$\6
${}\|v\MG\\{last\_pixel}\K\\{aloc};{}$\6
\&{if} (\\{gb\_trouble\_code})\1\5
\&{goto} \\{trouble};\2\6
\&{if} ${}(\|k>\T{0}\W\|v\I\|w){}$\1\5
${}\\{adjac}(\|v,\39\|w);{}$\2\6
\&{if} ${}(\|l>\T{0}\W\|v\I\|u[\|l-\T{1}]){}$\1\5
${}\\{adjac}(\|v,\39\|u[\|l-\T{1}]);{}$\2\6
\4${}\}{}$\2\2\par
\U23.\fi

\M{31}\B\X24:Local variables for \PB{\\{plane\_lisa}}\X${}\mathrel+\E{}$\6
\&{Vertex} ${}{*}{*}\|u{}$;\C{ table of vertices for previous $n$ pixels }\6
\&{Vertex} ${}{*}\|v{}$;\C{ vertex corresponding to position \PB{$[\|k,\|l]$} }%
\6
\&{Vertex} ${}{*}\|w{}$;\C{ vertex corresponding to position \PB{$[\|k-\T{1},%
\|l]$} }\6
\&{long} \\{aloc};\C{ $k*n+l$ }\par
\fi

\M{32}The \PB{\\{adjac}} routine makes two vertices adjacent, if they aren't
already.
A faster way to recognize duplicates would probably speed things up.

\Y\B\4\X15:Private subroutines\X${}\mathrel+\E{}$\6
\1\1\&{static} \&{void} ${}\\{adjac}(\|u,\39\|v){}$\6
\&{Vertex} ${}{*}\|u,\39{*}\|v;\2\2{}$\6
${}\{{}$\5
\1\&{Arc} ${}{*}\|a;{}$\7
\&{for} ${}(\|a\K\|u\MG\\{arcs};{}$ \|a; ${}\|a\K\|a\MG\\{next}){}$\1\6
\&{if} ${}(\|a\MG\\{tip}\E\|v){}$\1\5
\&{return};\2\2\6
${}\\{gb\_new\_edge}(\|u,\39\|v,\39\T{1\$L});{}$\6
\4${}\}{}$\2\par
\fi

\N{1}{33}Bipartite graphs. An even simpler class of Mona-Lisa-based graphs
is obtained by considering the \PB{\|m} rows and \PB{\|n} columns to be
individual
vertices, with a row adjacent to a column if the associated pixel value
is sufficiently large or sufficiently small. All edges have length~1.

The subroutine call \PB{$\\{bi\_lisa}(\|m,\|n,\\{m0},\\{m1},\\{n0},\\{n1},%
\\{thresh},\|c)$} constructs
the bipartite graph corresponding to the $m\times n$
digitization produced by \PB{\\{lisa}}, using parameters \PB{$(\\{m0},\\{m1},%
\\{n0},\\{n1})$} to
define a rectangular subpicture as described earlier.
The threshold parameter \PB{\\{thresh}} should be between 0 and~65535.
If the pixel value in row \PB{\|k} and column \PB{\|l} is at least \PB{$%
\\{thresh}/\T{65535}$} of
its maximum, vertices \PB{\|k} and~\PB{\|l} will be adjacent.
If \PB{$\|c\I\T{0}$}, however, the convention is reversed; vertices are then
adjacent when the corresponding pixel value is {\sl smaller\/} than
\PB{$\\{thresh}/\T{65535}$}. Thus adjacencies come from ``light'' areas of
da Vinci's painting when \PB{$\|c\K\T{0}$} and from ``dark'' areas when \PB{$%
\|c\I\T{0}$}. There
are \PB{$\|m+\|n$} vertices and up to $m\times n$ edges.

The actual pixel value is recorded in utility field \PB{$\|b.\|I$} of each arc,
and scaled to be in the range $[0,65535]$.

\Y\B\1\1\&{Graph} ${}{*}\\{bi\_lisa}(\|m,\39\|n,\39\\{m0},\39\\{m1},\39\\{n0},%
\39\\{n1},\39\\{thresh},\39\|c){}$\6
\&{unsigned} \&{long} \|m${},\39\|n{}$;\C{ number of rows and columns desired }%
\6
\&{unsigned} \&{long} \\{m0}${},\39\\{m1}{}$;\C{ input will be from rows $[\PB{%
\\{m0}}\,.\,.\,\PB{\\{m1}})$ }\6
\&{unsigned} \&{long} \\{n0}${},\39\\{n1}{}$;\C{ and from columns $[\PB{\\{n0}}%
\,.\,.\,\PB{\\{n1}})$ }\6
\&{unsigned} \&{long} \\{thresh};\C{ threshold defining adjacency }\6
\&{long} \|c;\C{ should we prefer dark pixels to light pixels? }\2\2\6
${}\{{}$\5
\1\X34:Local variables for \PB{\\{bi\_lisa}}\X\7
\\{init\_area}(\\{working\_storage});\6
\X35:Set up a bipartite graph with \PB{$\|m+\|n$} vertices\X;\6
\X36:Put the appropriate edges into the bigraph\X;\6
\\{gb\_free}(\\{working\_storage});\6
\&{if} (\\{gb\_trouble\_code})\5
${}\{{}$\1\6
\\{gb\_recycle}(\\{new\_graph});\6
\\{panic}(\\{alloc\_fault});\C{ oops, we ran out of memory somewhere back there
}\6
\4${}\}{}$\2\6
\&{return} \\{new\_graph};\6
\4${}\}{}$\2\par
\fi

\M{34}\B\X34:Local variables for \PB{\\{bi\_lisa}}\X${}\E{}$\6
\&{Graph} ${}{*}\\{new\_graph}{}$;\C{ the graph constructed by \PB{\\{bi%
\_lisa}} }\6
\&{register} \&{long} \|k${},\39\|l{}$;\C{ all-purpose indices }\6
\&{Area} \\{working\_storage};\C{ tables needed while \PB{\\{bi\_lisa}} does
its thinking }\6
\&{long} ${}{*}\|a{}$;\C{ the matrix constructed by \PB{\\{lisa}} }\6
\&{long} ${}{*}\\{apos}{}$;\C{ the location of \PB{$\|a[\|k,\|l]$} }\6
\&{register} \&{Vertex} ${}{*}\|u,\39{*}\|v{}$;\C{ current vertices of interest
}\par
\U33.\fi

\M{35}\B\X35:Set up a bipartite graph with \PB{$\|m+\|n$} vertices\X${}\E{}$\6
$\|a\K\\{lisa}(\|m,\39\|n,\39\T{65535\$L},\39\\{m0},\39\\{m1},\39\\{n0},\39%
\\{n1},\39\T{0\$L},\39\T{0\$L},\39\\{working\_storage});{}$\6
\&{if} ${}(\|a\E\NULL){}$\1\5
\&{return} ${}\NULL{}$;\C{ \PB{\\{panic\_code}} has been set by \PB{\\{lisa}} }%
\2\6
${}\\{sscanf}(\\{lisa\_id},\39\.{"lisa(\%lu,\%lu,65535,}\)\.{\%lu,\%lu,\%lu,%
\%lu"},\39{\AND}\|m,\39{\AND}\|n,\39{\AND}\\{m0},\39{\AND}\\{m1},\39{\AND}%
\\{n0},\39{\AND}\\{n1});{}$\6
${}\\{new\_graph}\K\\{gb\_new\_graph}(\|m+\|n);{}$\6
\&{if} ${}(\\{new\_graph}\E\NULL){}$\1\5
\\{panic}(\\{no\_room});\C{ out of memory before we're even started }\2\6
${}\\{sprintf}(\\{new\_graph}\MG\\{id},\39\.{"bi\_lisa(\%lu,\%lu,\%lu}\)\.{,%
\%lu,\%lu,\%lu,\%lu,\%c)}\)\.{"},\39\|m,\39\|n,\39\\{m0},\39\\{m1},\39\\{n0},%
\39\\{n1},\39\\{thresh},\39\|c\?\.{'1'}:\.{'0'});{}$\6
${}\\{new\_graph}\MG\\{util\_types}[\T{7}]\K\.{'I'}{}$;\C{ enable field \PB{$%
\|b.\|I$} }\6
${}\\{mark\_bipartite}(\\{new\_graph},\39\|m);{}$\6
\&{for} ${}(\|k\K\T{0},\39\|v\K\\{new\_graph}\MG\\{vertices};{}$ ${}\|k<\|m;{}$
${}\|k\PP,\39\|v\PP){}$\5
${}\{{}$\1\6
${}\\{sprintf}(\\{str\_buf},\39\.{"r\%ld"},\39\|k){}$;\C{ row vertices are
called \PB{\.{"r0"}}, \PB{\.{"r1"}}, etc. }\6
${}\|v\MG\\{name}\K\\{gb\_save\_string}(\\{str\_buf});{}$\6
\4${}\}{}$\2\6
\&{for} ${}(\|l\K\T{0};{}$ ${}\|l<\|n;{}$ ${}\|l\PP,\39\|v\PP){}$\5
${}\{{}$\1\6
${}\\{sprintf}(\\{str\_buf},\39\.{"c\%ld"},\39\|l){}$;\C{ column vertices are
called \PB{\.{"c0"}},                                             \PB{%
\.{"c1"}}, etc. }\6
${}\|v\MG\\{name}\K\\{gb\_save\_string}(\\{str\_buf});{}$\6
\4${}\}{}$\2\par
\U33.\fi

\M{36}Since we've called \PB{\\{lisa}} with \PB{$\|d\K\T{65535}$}, the
determination of
adjacency is simple.

\Y\B\4\X36:Put the appropriate edges into the bigraph\X${}\E{}$\6
\&{for} ${}(\|u\K\\{new\_graph}\MG\\{vertices},\39\\{apos}\K\|a;{}$ ${}\|u<%
\\{new\_graph}\MG\\{vertices}+\|m;{}$ ${}\|u\PP){}$\1\6
\&{for} ${}(\|v\K\\{new\_graph}\MG\\{vertices}+\|m;{}$ ${}\|v<\\{new\_graph}\MG%
\\{vertices}+\|m+\|n;{}$ ${}\\{apos}\PP,\39\|v\PP){}$\5
${}\{{}$\1\6
\&{if} ${}(\|c\?{*}\\{apos}<\\{thresh}:{*}\\{apos}\G\\{thresh}){}$\5
${}\{{}$\1\6
${}\\{gb\_new\_edge}(\|u,\39\|v,\39\T{1\$L});{}$\6
${}\|u\MG\\{arcs}\MG\|b.\|I\K\|v\MG\\{arcs}\MG\|b.\|I\K{*}\\{apos};{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\2\par
\U33.\fi

\N{1}{37}Index. As usual, we close with an index that
shows where the identifiers of \\{gb\_lisa} are defined and used.

\fi


\inx
\fin
\con
